// Code generated by protoc-gen-go.
// source: marathon.proto
// DO NOT EDIT!

/*
Package marathon is a generated protocol buffer package.


protoc --java_out=src/main/java/ --proto_path=/path/to/mesos/include/mesos/ --proto_path=src/main/proto/ src/main/proto/marathon.proto


It is generated from these files:
	marathon.proto

It has these top-level messages:
	Constraint
	HealthCheckDefinition
	ReadinessCheckDefinition
	ObsoleteIpAddress
	ObsoleteDiscoveryInfo
	NetworkDefinition
	ServiceDefinition
	UnreachableStrategy
	Json
	ResourceRoles
	MarathonTask
	MarathonApp
	ContainerInfo
	ExtendedContainerInfo
	Volume
	EventSubscribers
	StorageVersion
	UpgradeStrategyDefinition
	GroupDefinition
	DeploymentPlanDefinition
	TaskFailure
	ZKStoreEntry
	ResidencyDefinition
	Secret
	EnvVarReference
	EnvVarSecretRef
*/
package marathon

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import mesos "go.spiff.io/marty/mesospb/mesos"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type KillSelection int32

const (
	KillSelection_YoungestFirst KillSelection = 1
	KillSelection_OldestFirst   KillSelection = 2
)

var KillSelection_name = map[int32]string{
	1: "YoungestFirst",
	2: "OldestFirst",
}
var KillSelection_value = map[string]int32{
	"YoungestFirst": 1,
	"OldestFirst":   2,
}

func (x KillSelection) Enum() *KillSelection {
	p := new(KillSelection)
	*p = x
	return p
}
func (x KillSelection) String() string {
	return proto.EnumName(KillSelection_name, int32(x))
}
func (x *KillSelection) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(KillSelection_value, data, "KillSelection")
	if err != nil {
		return err
	}
	*x = KillSelection(value)
	return nil
}
func (KillSelection) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Constraint_Operator int32

const (
	// Field must be unique across all tasks.
	Constraint_UNIQUE Constraint_Operator = 0
	// Field must match the regex given by value.
	Constraint_LIKE Constraint_Operator = 1
	// Tasks will be clustered, i.e. all tasks need to have the same value. If value is not set, any value will be
	// accepted for the first task, and subsequent tasks must use that same value.
	Constraint_CLUSTER Constraint_Operator = 2
	// Tasks will be grouped by field. Value specifies the minimum size of each group.
	Constraint_GROUP_BY Constraint_Operator = 3
	// Field must not match the regex given by value.
	Constraint_UNLIKE Constraint_Operator = 4
	// Field will be grouped by field. Value specifies the maximum size of each group.
	Constraint_MAX_PER Constraint_Operator = 5
)

var Constraint_Operator_name = map[int32]string{
	0: "UNIQUE",
	1: "LIKE",
	2: "CLUSTER",
	3: "GROUP_BY",
	4: "UNLIKE",
	5: "MAX_PER",
}
var Constraint_Operator_value = map[string]int32{
	"UNIQUE":   0,
	"LIKE":     1,
	"CLUSTER":  2,
	"GROUP_BY": 3,
	"UNLIKE":   4,
	"MAX_PER":  5,
}

func (x Constraint_Operator) Enum() *Constraint_Operator {
	p := new(Constraint_Operator)
	*p = x
	return p
}
func (x Constraint_Operator) String() string {
	return proto.EnumName(Constraint_Operator_name, int32(x))
}
func (x *Constraint_Operator) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Constraint_Operator_value, data, "Constraint_Operator")
	if err != nil {
		return err
	}
	*x = Constraint_Operator(value)
	return nil
}
func (Constraint_Operator) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type HealthCheckDefinition_Protocol int32

const (
	HealthCheckDefinition_HTTP        HealthCheckDefinition_Protocol = 0
	HealthCheckDefinition_TCP         HealthCheckDefinition_Protocol = 1
	HealthCheckDefinition_COMMAND     HealthCheckDefinition_Protocol = 2
	HealthCheckDefinition_HTTPS       HealthCheckDefinition_Protocol = 3
	HealthCheckDefinition_MESOS_HTTP  HealthCheckDefinition_Protocol = 4
	HealthCheckDefinition_MESOS_HTTPS HealthCheckDefinition_Protocol = 5
	HealthCheckDefinition_MESOS_TCP   HealthCheckDefinition_Protocol = 6
)

var HealthCheckDefinition_Protocol_name = map[int32]string{
	0: "HTTP",
	1: "TCP",
	2: "COMMAND",
	3: "HTTPS",
	4: "MESOS_HTTP",
	5: "MESOS_HTTPS",
	6: "MESOS_TCP",
}
var HealthCheckDefinition_Protocol_value = map[string]int32{
	"HTTP":        0,
	"TCP":         1,
	"COMMAND":     2,
	"HTTPS":       3,
	"MESOS_HTTP":  4,
	"MESOS_HTTPS": 5,
	"MESOS_TCP":   6,
}

func (x HealthCheckDefinition_Protocol) Enum() *HealthCheckDefinition_Protocol {
	p := new(HealthCheckDefinition_Protocol)
	*p = x
	return p
}
func (x HealthCheckDefinition_Protocol) String() string {
	return proto.EnumName(HealthCheckDefinition_Protocol_name, int32(x))
}
func (x *HealthCheckDefinition_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HealthCheckDefinition_Protocol_value, data, "HealthCheckDefinition_Protocol")
	if err != nil {
		return err
	}
	*x = HealthCheckDefinition_Protocol(value)
	return nil
}
func (HealthCheckDefinition_Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{1, 0}
}

type ReadinessCheckDefinition_Protocol int32

const (
	ReadinessCheckDefinition_HTTP  ReadinessCheckDefinition_Protocol = 0
	ReadinessCheckDefinition_HTTPS ReadinessCheckDefinition_Protocol = 1
)

var ReadinessCheckDefinition_Protocol_name = map[int32]string{
	0: "HTTP",
	1: "HTTPS",
}
var ReadinessCheckDefinition_Protocol_value = map[string]int32{
	"HTTP":  0,
	"HTTPS": 1,
}

func (x ReadinessCheckDefinition_Protocol) Enum() *ReadinessCheckDefinition_Protocol {
	p := new(ReadinessCheckDefinition_Protocol)
	*p = x
	return p
}
func (x ReadinessCheckDefinition_Protocol) String() string {
	return proto.EnumName(ReadinessCheckDefinition_Protocol_name, int32(x))
}
func (x *ReadinessCheckDefinition_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReadinessCheckDefinition_Protocol_value, data, "ReadinessCheckDefinition_Protocol")
	if err != nil {
		return err
	}
	*x = ReadinessCheckDefinition_Protocol(value)
	return nil
}
func (ReadinessCheckDefinition_Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 0}
}

type NetworkDefinition_Mode int32

const (
	NetworkDefinition_UNKNOWN   NetworkDefinition_Mode = 0
	NetworkDefinition_HOST      NetworkDefinition_Mode = 1
	NetworkDefinition_CONTAINER NetworkDefinition_Mode = 2
	NetworkDefinition_BRIDGE    NetworkDefinition_Mode = 3
)

var NetworkDefinition_Mode_name = map[int32]string{
	0: "UNKNOWN",
	1: "HOST",
	2: "CONTAINER",
	3: "BRIDGE",
}
var NetworkDefinition_Mode_value = map[string]int32{
	"UNKNOWN":   0,
	"HOST":      1,
	"CONTAINER": 2,
	"BRIDGE":    3,
}

func (x NetworkDefinition_Mode) Enum() *NetworkDefinition_Mode {
	p := new(NetworkDefinition_Mode)
	*p = x
	return p
}
func (x NetworkDefinition_Mode) String() string {
	return proto.EnumName(NetworkDefinition_Mode_name, int32(x))
}
func (x *NetworkDefinition_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NetworkDefinition_Mode_value, data, "NetworkDefinition_Mode")
	if err != nil {
		return err
	}
	*x = NetworkDefinition_Mode(value)
	return nil
}
func (NetworkDefinition_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type MarathonTask_Condition int32

const (
	MarathonTask_Invalid     MarathonTask_Condition = 0
	MarathonTask_Reserved    MarathonTask_Condition = 1
	MarathonTask_Created     MarathonTask_Condition = 2
	MarathonTask_Error       MarathonTask_Condition = 3
	MarathonTask_Failed      MarathonTask_Condition = 4
	MarathonTask_Finished    MarathonTask_Condition = 5
	MarathonTask_Killed      MarathonTask_Condition = 6
	MarathonTask_Killing     MarathonTask_Condition = 7
	MarathonTask_Lost        MarathonTask_Condition = 8
	MarathonTask_Running     MarathonTask_Condition = 9
	MarathonTask_Staging     MarathonTask_Condition = 10
	MarathonTask_Starting    MarathonTask_Condition = 11
	MarathonTask_Unreachable MarathonTask_Condition = 12
	MarathonTask_Gone        MarathonTask_Condition = 13
	MarathonTask_Unknown     MarathonTask_Condition = 14
	MarathonTask_Dropped     MarathonTask_Condition = 15
)

var MarathonTask_Condition_name = map[int32]string{
	0:  "Invalid",
	1:  "Reserved",
	2:  "Created",
	3:  "Error",
	4:  "Failed",
	5:  "Finished",
	6:  "Killed",
	7:  "Killing",
	8:  "Lost",
	9:  "Running",
	10: "Staging",
	11: "Starting",
	12: "Unreachable",
	13: "Gone",
	14: "Unknown",
	15: "Dropped",
}
var MarathonTask_Condition_value = map[string]int32{
	"Invalid":     0,
	"Reserved":    1,
	"Created":     2,
	"Error":       3,
	"Failed":      4,
	"Finished":    5,
	"Killed":      6,
	"Killing":     7,
	"Lost":        8,
	"Running":     9,
	"Staging":     10,
	"Starting":    11,
	"Unreachable": 12,
	"Gone":        13,
	"Unknown":     14,
	"Dropped":     15,
}

func (x MarathonTask_Condition) Enum() *MarathonTask_Condition {
	p := new(MarathonTask_Condition)
	*p = x
	return p
}
func (x MarathonTask_Condition) String() string {
	return proto.EnumName(MarathonTask_Condition_name, int32(x))
}
func (x *MarathonTask_Condition) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MarathonTask_Condition_value, data, "MarathonTask_Condition")
	if err != nil {
		return err
	}
	*x = MarathonTask_Condition(value)
	return nil
}
func (MarathonTask_Condition) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

type MarathonTask_Reservation_State_Type int32

const (
	MarathonTask_Reservation_State_New       MarathonTask_Reservation_State_Type = 1
	MarathonTask_Reservation_State_Launched  MarathonTask_Reservation_State_Type = 2
	MarathonTask_Reservation_State_Suspended MarathonTask_Reservation_State_Type = 3
	MarathonTask_Reservation_State_Garbage   MarathonTask_Reservation_State_Type = 4
	MarathonTask_Reservation_State_Unknown   MarathonTask_Reservation_State_Type = 5
)

var MarathonTask_Reservation_State_Type_name = map[int32]string{
	1: "New",
	2: "Launched",
	3: "Suspended",
	4: "Garbage",
	5: "Unknown",
}
var MarathonTask_Reservation_State_Type_value = map[string]int32{
	"New":       1,
	"Launched":  2,
	"Suspended": 3,
	"Garbage":   4,
	"Unknown":   5,
}

func (x MarathonTask_Reservation_State_Type) Enum() *MarathonTask_Reservation_State_Type {
	p := new(MarathonTask_Reservation_State_Type)
	*p = x
	return p
}
func (x MarathonTask_Reservation_State_Type) String() string {
	return proto.EnumName(MarathonTask_Reservation_State_Type_name, int32(x))
}
func (x *MarathonTask_Reservation_State_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MarathonTask_Reservation_State_Type_value, data, "MarathonTask_Reservation_State_Type")
	if err != nil {
		return err
	}
	*x = MarathonTask_Reservation_State_Type(value)
	return nil
}
func (MarathonTask_Reservation_State_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0, 0, 0}
}

type MarathonTask_Reservation_State_Timeout_Reason int32

const (
	MarathonTask_Reservation_State_Timeout_RelaunchEscalationTimeout MarathonTask_Reservation_State_Timeout_Reason = 1
	MarathonTask_Reservation_State_Timeout_ReservationTimeout        MarathonTask_Reservation_State_Timeout_Reason = 2
)

var MarathonTask_Reservation_State_Timeout_Reason_name = map[int32]string{
	1: "RelaunchEscalationTimeout",
	2: "ReservationTimeout",
}
var MarathonTask_Reservation_State_Timeout_Reason_value = map[string]int32{
	"RelaunchEscalationTimeout": 1,
	"ReservationTimeout":        2,
}

func (x MarathonTask_Reservation_State_Timeout_Reason) Enum() *MarathonTask_Reservation_State_Timeout_Reason {
	p := new(MarathonTask_Reservation_State_Timeout_Reason)
	*p = x
	return p
}
func (x MarathonTask_Reservation_State_Timeout_Reason) String() string {
	return proto.EnumName(MarathonTask_Reservation_State_Timeout_Reason_name, int32(x))
}
func (x *MarathonTask_Reservation_State_Timeout_Reason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MarathonTask_Reservation_State_Timeout_Reason_value, data, "MarathonTask_Reservation_State_Timeout_Reason")
	if err != nil {
		return err
	}
	*x = MarathonTask_Reservation_State_Timeout_Reason(value)
	return nil
}
func (MarathonTask_Reservation_State_Timeout_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0, 0, 0, 0}
}

type StorageVersion_StorageFormat int32

const (
	StorageVersion_LEGACY            StorageVersion_StorageFormat = 0
	StorageVersion_PERSISTENCE_STORE StorageVersion_StorageFormat = 1
)

var StorageVersion_StorageFormat_name = map[int32]string{
	0: "LEGACY",
	1: "PERSISTENCE_STORE",
}
var StorageVersion_StorageFormat_value = map[string]int32{
	"LEGACY":            0,
	"PERSISTENCE_STORE": 1,
}

func (x StorageVersion_StorageFormat) Enum() *StorageVersion_StorageFormat {
	p := new(StorageVersion_StorageFormat)
	*p = x
	return p
}
func (x StorageVersion_StorageFormat) String() string {
	return proto.EnumName(StorageVersion_StorageFormat_name, int32(x))
}
func (x *StorageVersion_StorageFormat) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StorageVersion_StorageFormat_value, data, "StorageVersion_StorageFormat")
	if err != nil {
		return err
	}
	*x = StorageVersion_StorageFormat(value)
	return nil
}
func (StorageVersion_StorageFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 0}
}

type ResidencyDefinition_TaskLostBehavior int32

const (
	ResidencyDefinition_RELAUNCH_AFTER_TIMEOUT ResidencyDefinition_TaskLostBehavior = 0
	ResidencyDefinition_WAIT_FOREVER           ResidencyDefinition_TaskLostBehavior = 1
)

var ResidencyDefinition_TaskLostBehavior_name = map[int32]string{
	0: "RELAUNCH_AFTER_TIMEOUT",
	1: "WAIT_FOREVER",
}
var ResidencyDefinition_TaskLostBehavior_value = map[string]int32{
	"RELAUNCH_AFTER_TIMEOUT": 0,
	"WAIT_FOREVER":           1,
}

func (x ResidencyDefinition_TaskLostBehavior) Enum() *ResidencyDefinition_TaskLostBehavior {
	p := new(ResidencyDefinition_TaskLostBehavior)
	*p = x
	return p
}
func (x ResidencyDefinition_TaskLostBehavior) String() string {
	return proto.EnumName(ResidencyDefinition_TaskLostBehavior_name, int32(x))
}
func (x *ResidencyDefinition_TaskLostBehavior) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ResidencyDefinition_TaskLostBehavior_value, data, "ResidencyDefinition_TaskLostBehavior")
	if err != nil {
		return err
	}
	*x = ResidencyDefinition_TaskLostBehavior(value)
	return nil
}
func (ResidencyDefinition_TaskLostBehavior) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{22, 0}
}

type EnvVarReference_Type int32

const (
	EnvVarReference_UNKNOWN EnvVarReference_Type = 0
	EnvVarReference_SECRET  EnvVarReference_Type = 1
)

var EnvVarReference_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "SECRET",
}
var EnvVarReference_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"SECRET":  1,
}

func (x EnvVarReference_Type) Enum() *EnvVarReference_Type {
	p := new(EnvVarReference_Type)
	*p = x
	return p
}
func (x EnvVarReference_Type) String() string {
	return proto.EnumName(EnvVarReference_Type_name, int32(x))
}
func (x *EnvVarReference_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EnvVarReference_Type_value, data, "EnvVarReference_Type")
	if err != nil {
		return err
	}
	*x = EnvVarReference_Type(value)
	return nil
}
func (EnvVarReference_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{24, 0} }

type Constraint struct {
	Field            *string              `protobuf:"bytes,1,req,name=field" json:"field,omitempty"`
	Operator         *Constraint_Operator `protobuf:"varint,2,req,name=operator,enum=mesosphere.marathon.Constraint_Operator" json:"operator,omitempty"`
	Value            *string              `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *Constraint) Reset()                    { *m = Constraint{} }
func (m *Constraint) String() string            { return proto.CompactTextString(m) }
func (*Constraint) ProtoMessage()               {}
func (*Constraint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Constraint) GetField() string {
	if m != nil && m.Field != nil {
		return *m.Field
	}
	return ""
}

func (m *Constraint) GetOperator() Constraint_Operator {
	if m != nil && m.Operator != nil {
		return *m.Operator
	}
	return Constraint_UNIQUE
}

func (m *Constraint) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type HealthCheckDefinition struct {
	Protocol               *HealthCheckDefinition_Protocol `protobuf:"varint,1,req,name=protocol,enum=mesosphere.marathon.HealthCheckDefinition_Protocol" json:"protocol,omitempty"`
	PortIndex              *uint32                         `protobuf:"varint,2,opt,name=portIndex" json:"portIndex,omitempty"`
	GracePeriodSeconds     *uint32                         `protobuf:"varint,3,opt,name=gracePeriodSeconds,def=15" json:"gracePeriodSeconds,omitempty"`
	IntervalSeconds        *uint32                         `protobuf:"varint,4,opt,name=intervalSeconds,def=10" json:"intervalSeconds,omitempty"`
	TimeoutSeconds         *uint32                         `protobuf:"varint,5,opt,name=timeoutSeconds,def=20" json:"timeoutSeconds,omitempty"`
	Path                   *string                         `protobuf:"bytes,6,opt,name=path,def=/" json:"path,omitempty"`
	MaxConsecutiveFailures *uint32                         `protobuf:"varint,7,opt,name=maxConsecutiveFailures,def=3" json:"maxConsecutiveFailures,omitempty"`
	Command                *mesos.CommandInfo              `protobuf:"bytes,8,opt,name=command" json:"command,omitempty"`
	IgnoreHttp1Xx          *bool                           `protobuf:"varint,9,opt,name=ignoreHttp1xx,def=0" json:"ignoreHttp1xx,omitempty"`
	Port                   *uint32                         `protobuf:"varint,10,opt,name=port" json:"port,omitempty"`
	DelaySeconds           *uint32                         `protobuf:"varint,11,opt,name=delaySeconds,def=15" json:"delaySeconds,omitempty"`
	// portName and portIndex are exclusive; both must not be set
	PortName         *string `protobuf:"bytes,12,opt,name=portName" json:"portName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HealthCheckDefinition) Reset()                    { *m = HealthCheckDefinition{} }
func (m *HealthCheckDefinition) String() string            { return proto.CompactTextString(m) }
func (*HealthCheckDefinition) ProtoMessage()               {}
func (*HealthCheckDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

const Default_HealthCheckDefinition_GracePeriodSeconds uint32 = 15
const Default_HealthCheckDefinition_IntervalSeconds uint32 = 10
const Default_HealthCheckDefinition_TimeoutSeconds uint32 = 20
const Default_HealthCheckDefinition_Path string = "/"
const Default_HealthCheckDefinition_MaxConsecutiveFailures uint32 = 3
const Default_HealthCheckDefinition_IgnoreHttp1Xx bool = false
const Default_HealthCheckDefinition_DelaySeconds uint32 = 15

func (m *HealthCheckDefinition) GetProtocol() HealthCheckDefinition_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return HealthCheckDefinition_HTTP
}

func (m *HealthCheckDefinition) GetPortIndex() uint32 {
	if m != nil && m.PortIndex != nil {
		return *m.PortIndex
	}
	return 0
}

func (m *HealthCheckDefinition) GetGracePeriodSeconds() uint32 {
	if m != nil && m.GracePeriodSeconds != nil {
		return *m.GracePeriodSeconds
	}
	return Default_HealthCheckDefinition_GracePeriodSeconds
}

func (m *HealthCheckDefinition) GetIntervalSeconds() uint32 {
	if m != nil && m.IntervalSeconds != nil {
		return *m.IntervalSeconds
	}
	return Default_HealthCheckDefinition_IntervalSeconds
}

func (m *HealthCheckDefinition) GetTimeoutSeconds() uint32 {
	if m != nil && m.TimeoutSeconds != nil {
		return *m.TimeoutSeconds
	}
	return Default_HealthCheckDefinition_TimeoutSeconds
}

func (m *HealthCheckDefinition) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return Default_HealthCheckDefinition_Path
}

func (m *HealthCheckDefinition) GetMaxConsecutiveFailures() uint32 {
	if m != nil && m.MaxConsecutiveFailures != nil {
		return *m.MaxConsecutiveFailures
	}
	return Default_HealthCheckDefinition_MaxConsecutiveFailures
}

func (m *HealthCheckDefinition) GetCommand() *mesos.CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *HealthCheckDefinition) GetIgnoreHttp1Xx() bool {
	if m != nil && m.IgnoreHttp1Xx != nil {
		return *m.IgnoreHttp1Xx
	}
	return Default_HealthCheckDefinition_IgnoreHttp1Xx
}

func (m *HealthCheckDefinition) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *HealthCheckDefinition) GetDelaySeconds() uint32 {
	if m != nil && m.DelaySeconds != nil {
		return *m.DelaySeconds
	}
	return Default_HealthCheckDefinition_DelaySeconds
}

func (m *HealthCheckDefinition) GetPortName() string {
	if m != nil && m.PortName != nil {
		return *m.PortName
	}
	return ""
}

type ReadinessCheckDefinition struct {
	Name                   *string                            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Protocol               *ReadinessCheckDefinition_Protocol `protobuf:"varint,2,opt,name=protocol,enum=mesosphere.marathon.ReadinessCheckDefinition_Protocol" json:"protocol,omitempty"`
	Path                   *string                            `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
	PortName               *string                            `protobuf:"bytes,4,opt,name=portName" json:"portName,omitempty"`
	IntervalMillis         *uint64                            `protobuf:"varint,5,opt,name=intervalMillis" json:"intervalMillis,omitempty"`
	TimeoutMillis          *uint64                            `protobuf:"varint,6,opt,name=timeoutMillis" json:"timeoutMillis,omitempty"`
	HttpStatusCodeForReady []uint32                           `protobuf:"varint,7,rep,name=httpStatusCodeForReady" json:"httpStatusCodeForReady,omitempty"`
	PreserveLastResponse   *bool                              `protobuf:"varint,8,opt,name=preserveLastResponse" json:"preserveLastResponse,omitempty"`
	XXX_unrecognized       []byte                             `json:"-"`
}

func (m *ReadinessCheckDefinition) Reset()                    { *m = ReadinessCheckDefinition{} }
func (m *ReadinessCheckDefinition) String() string            { return proto.CompactTextString(m) }
func (*ReadinessCheckDefinition) ProtoMessage()               {}
func (*ReadinessCheckDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ReadinessCheckDefinition) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ReadinessCheckDefinition) GetProtocol() ReadinessCheckDefinition_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ReadinessCheckDefinition_HTTP
}

func (m *ReadinessCheckDefinition) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *ReadinessCheckDefinition) GetPortName() string {
	if m != nil && m.PortName != nil {
		return *m.PortName
	}
	return ""
}

func (m *ReadinessCheckDefinition) GetIntervalMillis() uint64 {
	if m != nil && m.IntervalMillis != nil {
		return *m.IntervalMillis
	}
	return 0
}

func (m *ReadinessCheckDefinition) GetTimeoutMillis() uint64 {
	if m != nil && m.TimeoutMillis != nil {
		return *m.TimeoutMillis
	}
	return 0
}

func (m *ReadinessCheckDefinition) GetHttpStatusCodeForReady() []uint32 {
	if m != nil {
		return m.HttpStatusCodeForReady
	}
	return nil
}

func (m *ReadinessCheckDefinition) GetPreserveLastResponse() bool {
	if m != nil && m.PreserveLastResponse != nil {
		return *m.PreserveLastResponse
	}
	return false
}

// deprecated, left here only to support migrations
type ObsoleteIpAddress struct {
	Groups           []string               `protobuf:"bytes,1,rep,name=groups" json:"groups,omitempty"`
	Labels           []*mesos.Label         `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty"`
	DiscoveryInfo    *ObsoleteDiscoveryInfo `protobuf:"bytes,3,opt,name=discoveryInfo" json:"discoveryInfo,omitempty"`
	NetworkName      *string                `protobuf:"bytes,4,opt,name=networkName" json:"networkName,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *ObsoleteIpAddress) Reset()                    { *m = ObsoleteIpAddress{} }
func (m *ObsoleteIpAddress) String() string            { return proto.CompactTextString(m) }
func (*ObsoleteIpAddress) ProtoMessage()               {}
func (*ObsoleteIpAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ObsoleteIpAddress) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ObsoleteIpAddress) GetLabels() []*mesos.Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObsoleteIpAddress) GetDiscoveryInfo() *ObsoleteDiscoveryInfo {
	if m != nil {
		return m.DiscoveryInfo
	}
	return nil
}

func (m *ObsoleteIpAddress) GetNetworkName() string {
	if m != nil && m.NetworkName != nil {
		return *m.NetworkName
	}
	return ""
}

// deprecated, left here only to support migrations
type ObsoleteDiscoveryInfo struct {
	Ports            []*mesos.Port `protobuf:"bytes,1,rep,name=ports" json:"ports,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *ObsoleteDiscoveryInfo) Reset()                    { *m = ObsoleteDiscoveryInfo{} }
func (m *ObsoleteDiscoveryInfo) String() string            { return proto.CompactTextString(m) }
func (*ObsoleteDiscoveryInfo) ProtoMessage()               {}
func (*ObsoleteDiscoveryInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ObsoleteDiscoveryInfo) GetPorts() []*mesos.Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

type NetworkDefinition struct {
	Mode             *NetworkDefinition_Mode `protobuf:"varint,1,opt,name=mode,enum=mesosphere.marathon.NetworkDefinition_Mode" json:"mode,omitempty"`
	Name             *string                 `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Labels           []*mesos.Label          `protobuf:"bytes,3,rep,name=labels" json:"labels,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *NetworkDefinition) Reset()                    { *m = NetworkDefinition{} }
func (m *NetworkDefinition) String() string            { return proto.CompactTextString(m) }
func (*NetworkDefinition) ProtoMessage()               {}
func (*NetworkDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *NetworkDefinition) GetMode() NetworkDefinition_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return NetworkDefinition_UNKNOWN
}

func (m *NetworkDefinition) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NetworkDefinition) GetLabels() []*mesos.Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

type ServiceDefinition struct {
	Id          *string            `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Cmd         *mesos.CommandInfo `protobuf:"bytes,2,req,name=cmd" json:"cmd,omitempty"`
	Instances   *uint32            `protobuf:"varint,3,req,name=instances" json:"instances,omitempty"`
	Resources   []*mesos.Resource  `protobuf:"bytes,4,rep,name=resources" json:"resources,omitempty"`
	Description *string            `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	Ports       []uint32           `protobuf:"varint,6,rep,name=ports" json:"ports,omitempty"`
	Constraints []*Constraint      `protobuf:"bytes,7,rep,name=constraints" json:"constraints,omitempty"`
	Executor    *string            `protobuf:"bytes,8,req,name=executor,def=" json:"executor,omitempty"`
	// optional double taskRateLimit = 9 [default = 1];
	OBSOLETEContainer        *ContainerInfo              `protobuf:"bytes,10,opt,name=OBSOLETE_container,json=OBSOLETEContainer" json:"OBSOLETE_container,omitempty"`
	Version                  *string                     `protobuf:"bytes,11,opt,name=version,def=1970-01-01T00:00:00.000Z" json:"version,omitempty"`
	HealthChecks             []*HealthCheckDefinition    `protobuf:"bytes,12,rep,name=healthChecks" json:"healthChecks,omitempty"`
	Backoff                  *int64                      `protobuf:"varint,13,opt,name=backoff,def=1000" json:"backoff,omitempty"`
	BackoffFactor            *float64                    `protobuf:"fixed64,14,opt,name=backoffFactor,def=1.15" json:"backoffFactor,omitempty"`
	UpgradeStrategy          *UpgradeStrategyDefinition  `protobuf:"bytes,15,opt,name=upgradeStrategy" json:"upgradeStrategy,omitempty"`
	Dependencies             []string                    `protobuf:"bytes,16,rep,name=dependencies" json:"dependencies,omitempty"`
	StoreUrls                []string                    `protobuf:"bytes,17,rep,name=storeUrls" json:"storeUrls,omitempty"`
	RequirePorts             *bool                       `protobuf:"varint,18,opt,name=require_ports,json=requirePorts,def=0" json:"require_ports,omitempty"`
	Container                *ExtendedContainerInfo      `protobuf:"bytes,19,opt,name=container" json:"container,omitempty"`
	Labels                   []*mesos.Parameter          `protobuf:"bytes,20,rep,name=labels" json:"labels,omitempty"`
	MaxLaunchDelay           *int64                      `protobuf:"varint,21,opt,name=maxLaunchDelay,def=3600000" json:"maxLaunchDelay,omitempty"`
	AcceptedResourceRoles    *ResourceRoles              `protobuf:"bytes,22,opt,name=acceptedResourceRoles" json:"acceptedResourceRoles,omitempty"`
	LastScalingAt            *int64                      `protobuf:"varint,23,opt,name=last_scaling_at,json=lastScalingAt" json:"last_scaling_at,omitempty"`
	LastConfigChangeAt       *int64                      `protobuf:"varint,24,opt,name=last_config_change_at,json=lastConfigChangeAt" json:"last_config_change_at,omitempty"`
	OBSOLETEIpAddress        *ObsoleteIpAddress          `protobuf:"bytes,25,opt,name=OBSOLETE_ipAddress,json=OBSOLETEIpAddress" json:"OBSOLETE_ipAddress,omitempty"`
	Residency                *ResidencyDefinition        `protobuf:"bytes,26,opt,name=residency" json:"residency,omitempty"`
	PortDefinitions          []*mesos.Port               `protobuf:"bytes,27,rep,name=portDefinitions" json:"portDefinitions,omitempty"`
	ReadinessCheckDefinition []*ReadinessCheckDefinition `protobuf:"bytes,28,rep,name=readinessCheckDefinition" json:"readinessCheckDefinition,omitempty"`
	Secrets                  []*Secret                   `protobuf:"bytes,29,rep,name=secrets" json:"secrets,omitempty"`
	EnvVarReferences         []*EnvVarReference          `protobuf:"bytes,30,rep,name=envVarReferences" json:"envVarReferences,omitempty"`
	TaskKillGracePeriod      *int64                      `protobuf:"varint,31,opt,name=taskKillGracePeriod" json:"taskKillGracePeriod,omitempty"`
	UnreachableStrategy      *UnreachableStrategy        `protobuf:"bytes,32,opt,name=unreachableStrategy" json:"unreachableStrategy,omitempty"`
	KillSelection            *KillSelection              `protobuf:"varint,33,opt,name=killSelection,enum=mesosphere.marathon.KillSelection,def=1" json:"killSelection,omitempty"`
	Networks                 []*NetworkDefinition        `protobuf:"bytes,34,rep,name=networks" json:"networks,omitempty"`
	XXX_unrecognized         []byte                      `json:"-"`
}

func (m *ServiceDefinition) Reset()                    { *m = ServiceDefinition{} }
func (m *ServiceDefinition) String() string            { return proto.CompactTextString(m) }
func (*ServiceDefinition) ProtoMessage()               {}
func (*ServiceDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

const Default_ServiceDefinition_Version string = "1970-01-01T00:00:00.000Z"
const Default_ServiceDefinition_Backoff int64 = 1000
const Default_ServiceDefinition_BackoffFactor float64 = 1.15
const Default_ServiceDefinition_RequirePorts bool = false
const Default_ServiceDefinition_MaxLaunchDelay int64 = 3600000
const Default_ServiceDefinition_KillSelection KillSelection = KillSelection_YoungestFirst

func (m *ServiceDefinition) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *ServiceDefinition) GetCmd() *mesos.CommandInfo {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *ServiceDefinition) GetInstances() uint32 {
	if m != nil && m.Instances != nil {
		return *m.Instances
	}
	return 0
}

func (m *ServiceDefinition) GetResources() []*mesos.Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ServiceDefinition) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *ServiceDefinition) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ServiceDefinition) GetConstraints() []*Constraint {
	if m != nil {
		return m.Constraints
	}
	return nil
}

func (m *ServiceDefinition) GetExecutor() string {
	if m != nil && m.Executor != nil {
		return *m.Executor
	}
	return ""
}

func (m *ServiceDefinition) GetOBSOLETEContainer() *ContainerInfo {
	if m != nil {
		return m.OBSOLETEContainer
	}
	return nil
}

func (m *ServiceDefinition) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_ServiceDefinition_Version
}

func (m *ServiceDefinition) GetHealthChecks() []*HealthCheckDefinition {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

func (m *ServiceDefinition) GetBackoff() int64 {
	if m != nil && m.Backoff != nil {
		return *m.Backoff
	}
	return Default_ServiceDefinition_Backoff
}

func (m *ServiceDefinition) GetBackoffFactor() float64 {
	if m != nil && m.BackoffFactor != nil {
		return *m.BackoffFactor
	}
	return Default_ServiceDefinition_BackoffFactor
}

func (m *ServiceDefinition) GetUpgradeStrategy() *UpgradeStrategyDefinition {
	if m != nil {
		return m.UpgradeStrategy
	}
	return nil
}

func (m *ServiceDefinition) GetDependencies() []string {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func (m *ServiceDefinition) GetStoreUrls() []string {
	if m != nil {
		return m.StoreUrls
	}
	return nil
}

func (m *ServiceDefinition) GetRequirePorts() bool {
	if m != nil && m.RequirePorts != nil {
		return *m.RequirePorts
	}
	return Default_ServiceDefinition_RequirePorts
}

func (m *ServiceDefinition) GetContainer() *ExtendedContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *ServiceDefinition) GetLabels() []*mesos.Parameter {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ServiceDefinition) GetMaxLaunchDelay() int64 {
	if m != nil && m.MaxLaunchDelay != nil {
		return *m.MaxLaunchDelay
	}
	return Default_ServiceDefinition_MaxLaunchDelay
}

func (m *ServiceDefinition) GetAcceptedResourceRoles() *ResourceRoles {
	if m != nil {
		return m.AcceptedResourceRoles
	}
	return nil
}

func (m *ServiceDefinition) GetLastScalingAt() int64 {
	if m != nil && m.LastScalingAt != nil {
		return *m.LastScalingAt
	}
	return 0
}

func (m *ServiceDefinition) GetLastConfigChangeAt() int64 {
	if m != nil && m.LastConfigChangeAt != nil {
		return *m.LastConfigChangeAt
	}
	return 0
}

func (m *ServiceDefinition) GetOBSOLETEIpAddress() *ObsoleteIpAddress {
	if m != nil {
		return m.OBSOLETEIpAddress
	}
	return nil
}

func (m *ServiceDefinition) GetResidency() *ResidencyDefinition {
	if m != nil {
		return m.Residency
	}
	return nil
}

func (m *ServiceDefinition) GetPortDefinitions() []*mesos.Port {
	if m != nil {
		return m.PortDefinitions
	}
	return nil
}

func (m *ServiceDefinition) GetReadinessCheckDefinition() []*ReadinessCheckDefinition {
	if m != nil {
		return m.ReadinessCheckDefinition
	}
	return nil
}

func (m *ServiceDefinition) GetSecrets() []*Secret {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *ServiceDefinition) GetEnvVarReferences() []*EnvVarReference {
	if m != nil {
		return m.EnvVarReferences
	}
	return nil
}

func (m *ServiceDefinition) GetTaskKillGracePeriod() int64 {
	if m != nil && m.TaskKillGracePeriod != nil {
		return *m.TaskKillGracePeriod
	}
	return 0
}

func (m *ServiceDefinition) GetUnreachableStrategy() *UnreachableStrategy {
	if m != nil {
		return m.UnreachableStrategy
	}
	return nil
}

func (m *ServiceDefinition) GetKillSelection() KillSelection {
	if m != nil && m.KillSelection != nil {
		return *m.KillSelection
	}
	return Default_ServiceDefinition_KillSelection
}

func (m *ServiceDefinition) GetNetworks() []*NetworkDefinition {
	if m != nil {
		return m.Networks
	}
	return nil
}

type UnreachableStrategy struct {
	// UnreachableDisabled is represented by both of these fields missing
	InactiveAfterSeconds *uint64 `protobuf:"varint,1,opt,name=inactiveAfterSeconds,def=900" json:"inactiveAfterSeconds,omitempty"`
	ExpungeAfterSeconds  *uint64 `protobuf:"varint,2,opt,name=expungeAfterSeconds,def=604800" json:"expungeAfterSeconds,omitempty"`
	XXX_unrecognized     []byte  `json:"-"`
}

func (m *UnreachableStrategy) Reset()                    { *m = UnreachableStrategy{} }
func (m *UnreachableStrategy) String() string            { return proto.CompactTextString(m) }
func (*UnreachableStrategy) ProtoMessage()               {}
func (*UnreachableStrategy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

const Default_UnreachableStrategy_InactiveAfterSeconds uint64 = 900
const Default_UnreachableStrategy_ExpungeAfterSeconds uint64 = 604800

func (m *UnreachableStrategy) GetInactiveAfterSeconds() uint64 {
	if m != nil && m.InactiveAfterSeconds != nil {
		return *m.InactiveAfterSeconds
	}
	return Default_UnreachableStrategy_InactiveAfterSeconds
}

func (m *UnreachableStrategy) GetExpungeAfterSeconds() uint64 {
	if m != nil && m.ExpungeAfterSeconds != nil {
		return *m.ExpungeAfterSeconds
	}
	return Default_UnreachableStrategy_ExpungeAfterSeconds
}

// we serialize PodDefinition and Instances as json, only required for legacy content
type Json struct {
	Json             *string `protobuf:"bytes,1,req,name=json" json:"json,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Json) Reset()                    { *m = Json{} }
func (m *Json) String() string            { return proto.CompactTextString(m) }
func (*Json) ProtoMessage()               {}
func (*Json) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Json) GetJson() string {
	if m != nil && m.Json != nil {
		return *m.Json
	}
	return ""
}

type ResourceRoles struct {
	Role             []string `protobuf:"bytes,1,rep,name=role" json:"role,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ResourceRoles) Reset()                    { *m = ResourceRoles{} }
func (m *ResourceRoles) String() string            { return proto.CompactTextString(m) }
func (*ResourceRoles) ProtoMessage()               {}
func (*ResourceRoles) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ResourceRoles) GetRole() []string {
	if m != nil {
		return m.Role
	}
	return nil
}

type MarathonTask struct {
	Id                 *string                   `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	OBSOLETEHost       *string                   `protobuf:"bytes,2,opt,name=OBSOLETE_host,json=OBSOLETEHost" json:"OBSOLETE_host,omitempty"`
	Ports              []uint32                  `protobuf:"varint,3,rep,name=ports" json:"ports,omitempty"`
	OBSOLETEAttributes []*mesos.Attribute        `protobuf:"bytes,4,rep,name=OBSOLETE_attributes,json=OBSOLETEAttributes" json:"OBSOLETE_attributes,omitempty"`
	StagedAt           *int64                    `protobuf:"varint,5,opt,name=staged_at,json=stagedAt" json:"staged_at,omitempty"`
	StartedAt          *int64                    `protobuf:"varint,6,opt,name=started_at,json=startedAt" json:"started_at,omitempty"`
	OBSOLETEStatuses   []*mesos.TaskStatus       `protobuf:"bytes,7,rep,name=OBSOLETE_statuses,json=OBSOLETEStatuses" json:"OBSOLETE_statuses,omitempty"`
	Version            *string                   `protobuf:"bytes,8,opt,name=version,def=1970-01-01T00:00:00.000Z" json:"version,omitempty"`
	Status             *mesos.TaskStatus         `protobuf:"bytes,9,opt,name=status" json:"status,omitempty"`
	OBSOLETESlaveId    *mesos.SlaveID            `protobuf:"bytes,10,opt,name=OBSOLETE_slaveId,json=OBSOLETESlaveId" json:"OBSOLETE_slaveId,omitempty"`
	OBSOLETENetworks   []*mesos.NetworkInfo      `protobuf:"bytes,11,rep,name=OBSOLETE_networks,json=OBSOLETENetworks" json:"OBSOLETE_networks,omitempty"`
	Reservation        *MarathonTask_Reservation `protobuf:"bytes,12,opt,name=reservation" json:"reservation,omitempty"`
	Condition          *MarathonTask_Condition   `protobuf:"varint,13,opt,name=condition,enum=mesosphere.marathon.MarathonTask_Condition" json:"condition,omitempty"`
	XXX_unrecognized   []byte                    `json:"-"`
}

func (m *MarathonTask) Reset()                    { *m = MarathonTask{} }
func (m *MarathonTask) String() string            { return proto.CompactTextString(m) }
func (*MarathonTask) ProtoMessage()               {}
func (*MarathonTask) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

const Default_MarathonTask_Version string = "1970-01-01T00:00:00.000Z"

func (m *MarathonTask) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *MarathonTask) GetOBSOLETEHost() string {
	if m != nil && m.OBSOLETEHost != nil {
		return *m.OBSOLETEHost
	}
	return ""
}

func (m *MarathonTask) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *MarathonTask) GetOBSOLETEAttributes() []*mesos.Attribute {
	if m != nil {
		return m.OBSOLETEAttributes
	}
	return nil
}

func (m *MarathonTask) GetStagedAt() int64 {
	if m != nil && m.StagedAt != nil {
		return *m.StagedAt
	}
	return 0
}

func (m *MarathonTask) GetStartedAt() int64 {
	if m != nil && m.StartedAt != nil {
		return *m.StartedAt
	}
	return 0
}

func (m *MarathonTask) GetOBSOLETEStatuses() []*mesos.TaskStatus {
	if m != nil {
		return m.OBSOLETEStatuses
	}
	return nil
}

func (m *MarathonTask) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_MarathonTask_Version
}

func (m *MarathonTask) GetStatus() *mesos.TaskStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *MarathonTask) GetOBSOLETESlaveId() *mesos.SlaveID {
	if m != nil {
		return m.OBSOLETESlaveId
	}
	return nil
}

func (m *MarathonTask) GetOBSOLETENetworks() []*mesos.NetworkInfo {
	if m != nil {
		return m.OBSOLETENetworks
	}
	return nil
}

func (m *MarathonTask) GetReservation() *MarathonTask_Reservation {
	if m != nil {
		return m.Reservation
	}
	return nil
}

func (m *MarathonTask) GetCondition() MarathonTask_Condition {
	if m != nil && m.Condition != nil {
		return *m.Condition
	}
	return MarathonTask_Invalid
}

type MarathonTask_Reservation struct {
	LocalVolumeIds   []string                        `protobuf:"bytes,1,rep,name=local_volume_ids,json=localVolumeIds" json:"local_volume_ids,omitempty"`
	State            *MarathonTask_Reservation_State `protobuf:"bytes,2,req,name=state" json:"state,omitempty"`
	XXX_unrecognized []byte                          `json:"-"`
}

func (m *MarathonTask_Reservation) Reset()                    { *m = MarathonTask_Reservation{} }
func (m *MarathonTask_Reservation) String() string            { return proto.CompactTextString(m) }
func (*MarathonTask_Reservation) ProtoMessage()               {}
func (*MarathonTask_Reservation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

func (m *MarathonTask_Reservation) GetLocalVolumeIds() []string {
	if m != nil {
		return m.LocalVolumeIds
	}
	return nil
}

func (m *MarathonTask_Reservation) GetState() *MarathonTask_Reservation_State {
	if m != nil {
		return m.State
	}
	return nil
}

type MarathonTask_Reservation_State struct {
	Type             *MarathonTask_Reservation_State_Type    `protobuf:"varint,1,req,name=type,enum=mesosphere.marathon.MarathonTask_Reservation_State_Type" json:"type,omitempty"`
	Timeout          *MarathonTask_Reservation_State_Timeout `protobuf:"bytes,2,opt,name=timeout" json:"timeout,omitempty"`
	XXX_unrecognized []byte                                  `json:"-"`
}

func (m *MarathonTask_Reservation_State) Reset()         { *m = MarathonTask_Reservation_State{} }
func (m *MarathonTask_Reservation_State) String() string { return proto.CompactTextString(m) }
func (*MarathonTask_Reservation_State) ProtoMessage()    {}
func (*MarathonTask_Reservation_State) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0, 0}
}

func (m *MarathonTask_Reservation_State) GetType() MarathonTask_Reservation_State_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return MarathonTask_Reservation_State_New
}

func (m *MarathonTask_Reservation_State) GetTimeout() *MarathonTask_Reservation_State_Timeout {
	if m != nil {
		return m.Timeout
	}
	return nil
}

type MarathonTask_Reservation_State_Timeout struct {
	Initiated        *int64                                         `protobuf:"varint,1,req,name=initiated" json:"initiated,omitempty"`
	Deadline         *int64                                         `protobuf:"varint,2,req,name=deadline" json:"deadline,omitempty"`
	Reason           *MarathonTask_Reservation_State_Timeout_Reason `protobuf:"varint,3,req,name=reason,enum=mesosphere.marathon.MarathonTask_Reservation_State_Timeout_Reason" json:"reason,omitempty"`
	XXX_unrecognized []byte                                         `json:"-"`
}

func (m *MarathonTask_Reservation_State_Timeout) Reset() {
	*m = MarathonTask_Reservation_State_Timeout{}
}
func (m *MarathonTask_Reservation_State_Timeout) String() string { return proto.CompactTextString(m) }
func (*MarathonTask_Reservation_State_Timeout) ProtoMessage()    {}
func (*MarathonTask_Reservation_State_Timeout) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0, 0, 0}
}

func (m *MarathonTask_Reservation_State_Timeout) GetInitiated() int64 {
	if m != nil && m.Initiated != nil {
		return *m.Initiated
	}
	return 0
}

func (m *MarathonTask_Reservation_State_Timeout) GetDeadline() int64 {
	if m != nil && m.Deadline != nil {
		return *m.Deadline
	}
	return 0
}

func (m *MarathonTask_Reservation_State_Timeout) GetReason() MarathonTask_Reservation_State_Timeout_Reason {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return MarathonTask_Reservation_State_Timeout_RelaunchEscalationTimeout
}

type MarathonApp struct {
	Name             *string         `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Tasks            []*MarathonTask `protobuf:"bytes,2,rep,name=tasks" json:"tasks,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *MarathonApp) Reset()                    { *m = MarathonApp{} }
func (m *MarathonApp) String() string            { return proto.CompactTextString(m) }
func (*MarathonApp) ProtoMessage()               {}
func (*MarathonApp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *MarathonApp) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MarathonApp) GetTasks() []*MarathonTask {
	if m != nil {
		return m.Tasks
	}
	return nil
}

type ContainerInfo struct {
	Image            []byte   `protobuf:"bytes,1,req,name=image,def=" json:"image,omitempty"`
	Options          [][]byte `protobuf:"bytes,2,rep,name=options" json:"options,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ContainerInfo) Reset()                    { *m = ContainerInfo{} }
func (m *ContainerInfo) String() string            { return proto.CompactTextString(m) }
func (*ContainerInfo) ProtoMessage()               {}
func (*ContainerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ContainerInfo) GetImage() []byte {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *ContainerInfo) GetOptions() [][]byte {
	if m != nil {
		return m.Options
	}
	return nil
}

// Copied from mesos.proto and adjusted to meet the needs for persistent volumes
// Extends DockerInfo.PortMapping to include `service_port`.
type ExtendedContainerInfo struct {
	Type             *mesos.ContainerInfo_Type              `protobuf:"varint,1,req,name=type,enum=mesos.ContainerInfo_Type" json:"type,omitempty"`
	Volumes          []*Volume                              `protobuf:"bytes,2,rep,name=volumes" json:"volumes,omitempty"`
	PortMappings     []*ExtendedContainerInfo_PortMapping   `protobuf:"bytes,6,rep,name=port_mappings,json=portMappings" json:"port_mappings,omitempty"`
	Docker           *ExtendedContainerInfo_DockerInfo      `protobuf:"bytes,3,opt,name=docker" json:"docker,omitempty"`
	MesosDocker      *ExtendedContainerInfo_MesosDockerInfo `protobuf:"bytes,4,opt,name=mesosDocker" json:"mesosDocker,omitempty"`
	MesosAppC        *ExtendedContainerInfo_MesosAppCInfo   `protobuf:"bytes,5,opt,name=mesosAppC" json:"mesosAppC,omitempty"`
	XXX_unrecognized []byte                                 `json:"-"`
}

func (m *ExtendedContainerInfo) Reset()                    { *m = ExtendedContainerInfo{} }
func (m *ExtendedContainerInfo) String() string            { return proto.CompactTextString(m) }
func (*ExtendedContainerInfo) ProtoMessage()               {}
func (*ExtendedContainerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ExtendedContainerInfo) GetType() mesos.ContainerInfo_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return mesos.ContainerInfo_DOCKER
}

func (m *ExtendedContainerInfo) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *ExtendedContainerInfo) GetPortMappings() []*ExtendedContainerInfo_PortMapping {
	if m != nil {
		return m.PortMappings
	}
	return nil
}

func (m *ExtendedContainerInfo) GetDocker() *ExtendedContainerInfo_DockerInfo {
	if m != nil {
		return m.Docker
	}
	return nil
}

func (m *ExtendedContainerInfo) GetMesosDocker() *ExtendedContainerInfo_MesosDockerInfo {
	if m != nil {
		return m.MesosDocker
	}
	return nil
}

func (m *ExtendedContainerInfo) GetMesosAppC() *ExtendedContainerInfo_MesosAppCInfo {
	if m != nil {
		return m.MesosAppC
	}
	return nil
}

// Docker on a Docker engine
type ExtendedContainerInfo_DockerInfo struct {
	Image *string `protobuf:"bytes,1,req,name=image" json:"image,omitempty"`
	// deprecated in favor of ServiceDefinition.networks since 1.5
	OBSOLETENetwork *mesos.ContainerInfo_DockerInfo_Network `protobuf:"varint,2,opt,name=OBSOLETE_network,json=OBSOLETENetwork,enum=mesos.ContainerInfo_DockerInfo_Network,def=1" json:"OBSOLETE_network,omitempty"`
	// deprecated in favor of ExtendedContainerInfo.port_mappings, since 1.5
	OBSOLETEPortMappings []*ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping `protobuf:"bytes,3,rep,name=OBSOLETE_port_mappings,json=OBSOLETEPortMappings" json:"OBSOLETE_port_mappings,omitempty"`
	Privileged           *bool                                                         `protobuf:"varint,4,opt,name=privileged,def=0" json:"privileged,omitempty"`
	// Allowing arbitrary parameters to be passed to docker CLI.
	// Note that anything passed to this field is not guaranteed
	// to be supported moving forward, as we might move away from
	// the docker CLI.
	Parameters []*mesos.Parameter `protobuf:"bytes,5,rep,name=parameters" json:"parameters,omitempty"`
	// With this flag set to true, the docker containerizer will
	// pull the docker image from the registry even if the image
	// is already downloaded on the agent.
	ForcePullImage   *bool  `protobuf:"varint,6,opt,name=force_pull_image,json=forcePullImage" json:"force_pull_image,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ExtendedContainerInfo_DockerInfo) Reset()         { *m = ExtendedContainerInfo_DockerInfo{} }
func (m *ExtendedContainerInfo_DockerInfo) String() string { return proto.CompactTextString(m) }
func (*ExtendedContainerInfo_DockerInfo) ProtoMessage()    {}
func (*ExtendedContainerInfo_DockerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 0}
}

const Default_ExtendedContainerInfo_DockerInfo_OBSOLETENetwork mesos.ContainerInfo_DockerInfo_Network = mesos.ContainerInfo_DockerInfo_HOST
const Default_ExtendedContainerInfo_DockerInfo_Privileged bool = false

func (m *ExtendedContainerInfo_DockerInfo) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *ExtendedContainerInfo_DockerInfo) GetOBSOLETENetwork() mesos.ContainerInfo_DockerInfo_Network {
	if m != nil && m.OBSOLETENetwork != nil {
		return *m.OBSOLETENetwork
	}
	return Default_ExtendedContainerInfo_DockerInfo_OBSOLETENetwork
}

func (m *ExtendedContainerInfo_DockerInfo) GetOBSOLETEPortMappings() []*ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping {
	if m != nil {
		return m.OBSOLETEPortMappings
	}
	return nil
}

func (m *ExtendedContainerInfo_DockerInfo) GetPrivileged() bool {
	if m != nil && m.Privileged != nil {
		return *m.Privileged
	}
	return Default_ExtendedContainerInfo_DockerInfo_Privileged
}

func (m *ExtendedContainerInfo_DockerInfo) GetParameters() []*mesos.Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *ExtendedContainerInfo_DockerInfo) GetForcePullImage() bool {
	if m != nil && m.ForcePullImage != nil {
		return *m.ForcePullImage
	}
	return false
}

// deprecated in favor of ExtendedContainerInfo.PortMapping,since 1.5
type ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping struct {
	HostPort         *uint32        `protobuf:"varint,1,opt,name=host_port,json=hostPort" json:"host_port,omitempty"`
	ContainerPort    *uint32        `protobuf:"varint,2,req,name=container_port,json=containerPort" json:"container_port,omitempty"`
	Protocol         *string        `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
	Name             *string        `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Labels           []*mesos.Label `protobuf:"bytes,5,rep,name=labels" json:"labels,omitempty"`
	ServicePort      *uint32        `protobuf:"varint,100,opt,name=service_port,json=servicePort,def=0" json:"service_port,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping) Reset() {
	*m = ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping{}
}
func (m *ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping) String() string {
	return proto.CompactTextString(m)
}
func (*ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping) ProtoMessage() {}
func (*ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 0, 0}
}

const Default_ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping_ServicePort uint32 = 0

func (m *ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping) GetHostPort() uint32 {
	if m != nil && m.HostPort != nil {
		return *m.HostPort
	}
	return 0
}

func (m *ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping) GetContainerPort() uint32 {
	if m != nil && m.ContainerPort != nil {
		return *m.ContainerPort
	}
	return 0
}

func (m *ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

func (m *ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping) GetLabels() []*mesos.Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping) GetServicePort() uint32 {
	if m != nil && m.ServicePort != nil {
		return *m.ServicePort
	}
	return Default_ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping_ServicePort
}

// Docker on the universal Mesos engine
type ExtendedContainerInfo_MesosDockerInfo struct {
	// The name of the image. Expected format:
	//   [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG|@TYPE:DIGEST]
	//
	// See: https://docs.docker.com/reference/commandline/pull/
	Image *string `protobuf:"bytes,1,req,name=image" json:"image,omitempty"`
	// Credential to authenticate with docker registry.
	// NOTE: This is not encrypted, therefore framework and operators
	// should enable SSL when passing this information.
	Credential *mesos.Credential `protobuf:"bytes,2,opt,name=credential" json:"credential,omitempty"`
	// With this flag set to true, the universal Mesos containerizer will
	// pull the docker image from the registry even if the image
	// is already downloaded on the agent.
	ForcePullImage   *bool  `protobuf:"varint,3,opt,name=force_pull_image,json=forcePullImage" json:"force_pull_image,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ExtendedContainerInfo_MesosDockerInfo) Reset()         { *m = ExtendedContainerInfo_MesosDockerInfo{} }
func (m *ExtendedContainerInfo_MesosDockerInfo) String() string { return proto.CompactTextString(m) }
func (*ExtendedContainerInfo_MesosDockerInfo) ProtoMessage()    {}
func (*ExtendedContainerInfo_MesosDockerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 1}
}

func (m *ExtendedContainerInfo_MesosDockerInfo) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *ExtendedContainerInfo_MesosDockerInfo) GetCredential() *mesos.Credential {
	if m != nil {
		return m.Credential
	}
	return nil
}

func (m *ExtendedContainerInfo_MesosDockerInfo) GetForcePullImage() bool {
	if m != nil && m.ForcePullImage != nil {
		return *m.ForcePullImage
	}
	return false
}

// AppC on the universal Mesos engine
type ExtendedContainerInfo_MesosAppCInfo struct {
	// The name of the image.
	Image *string `protobuf:"bytes,1,req,name=image" json:"image,omitempty"`
	// An image ID is a string of the format "hash-value", where
	// "hash" is the hash algorithm used and "value" is the hex
	// encoded string of the digest. Currently the only permitted
	// hash algorithm is sha512.
	Id *string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Optional labels. Suggested labels: "version", "os", and "arch".
	Labels []*mesos.Label `protobuf:"bytes,3,rep,name=labels" json:"labels,omitempty"`
	// With this flag set to true, the universal Mesos containerizer will
	// pull the docker image from the registry even if the image
	// is already downloaded on the agent.
	ForcePullImage   *bool  `protobuf:"varint,4,opt,name=force_pull_image,json=forcePullImage" json:"force_pull_image,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ExtendedContainerInfo_MesosAppCInfo) Reset()         { *m = ExtendedContainerInfo_MesosAppCInfo{} }
func (m *ExtendedContainerInfo_MesosAppCInfo) String() string { return proto.CompactTextString(m) }
func (*ExtendedContainerInfo_MesosAppCInfo) ProtoMessage()    {}
func (*ExtendedContainerInfo_MesosAppCInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 2}
}

func (m *ExtendedContainerInfo_MesosAppCInfo) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *ExtendedContainerInfo_MesosAppCInfo) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *ExtendedContainerInfo_MesosAppCInfo) GetLabels() []*mesos.Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ExtendedContainerInfo_MesosAppCInfo) GetForcePullImage() bool {
	if m != nil && m.ForcePullImage != nil {
		return *m.ForcePullImage
	}
	return false
}

type ExtendedContainerInfo_PortMapping struct {
	HostPort         *uint32        `protobuf:"varint,1,opt,name=host_port,json=hostPort" json:"host_port,omitempty"`
	ContainerPort    *uint32        `protobuf:"varint,2,req,name=container_port,json=containerPort" json:"container_port,omitempty"`
	Protocol         *string        `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
	Name             *string        `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Labels           []*mesos.Label `protobuf:"bytes,5,rep,name=labels" json:"labels,omitempty"`
	ServicePort      *uint32        `protobuf:"varint,6,opt,name=service_port,json=servicePort,def=0" json:"service_port,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ExtendedContainerInfo_PortMapping) Reset()         { *m = ExtendedContainerInfo_PortMapping{} }
func (m *ExtendedContainerInfo_PortMapping) String() string { return proto.CompactTextString(m) }
func (*ExtendedContainerInfo_PortMapping) ProtoMessage()    {}
func (*ExtendedContainerInfo_PortMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 3}
}

const Default_ExtendedContainerInfo_PortMapping_ServicePort uint32 = 0

func (m *ExtendedContainerInfo_PortMapping) GetHostPort() uint32 {
	if m != nil && m.HostPort != nil {
		return *m.HostPort
	}
	return 0
}

func (m *ExtendedContainerInfo_PortMapping) GetContainerPort() uint32 {
	if m != nil && m.ContainerPort != nil {
		return *m.ContainerPort
	}
	return 0
}

func (m *ExtendedContainerInfo_PortMapping) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

func (m *ExtendedContainerInfo_PortMapping) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExtendedContainerInfo_PortMapping) GetLabels() []*mesos.Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ExtendedContainerInfo_PortMapping) GetServicePort() uint32 {
	if m != nil && m.ServicePort != nil {
		return *m.ServicePort
	}
	return Default_ExtendedContainerInfo_PortMapping_ServicePort
}

// Copied from mesos.proto and adjusted to meet the needs of persistent volumes
// Describes a volume mapping either from host to container or vice
// versa. Both paths can either refer to a directory or a file.
type Volume struct {
	Mode *mesos.Volume_Mode `protobuf:"varint,3,req,name=mode,enum=mesos.Volume_Mode" json:"mode,omitempty"`
	// Path pointing to a directory or file in the container. If the
	// path is a relative path, it is relative to the container work
	// directory. If the path is an absolute path, that path must
	// already exist.
	ContainerPath *string `protobuf:"bytes,1,req,name=container_path,json=containerPath" json:"container_path,omitempty"`
	// Absolute path pointing to a directory or file on the host or a
	// path relative to the container work directory.
	HostPath *string `protobuf:"bytes,2,opt,name=host_path,json=hostPath" json:"host_path,omitempty"`
	// The source of the volume is an Image which describes a root
	// filesystem which will be provisioned by Mesos.
	Image *mesos.Image `protobuf:"bytes,4,opt,name=image" json:"image,omitempty"`
	// Defines a Persistent Volume; implies no hostPath or external.
	Persistent *Volume_PersistentVolumeInfo `protobuf:"bytes,5,opt,name=persistent" json:"persistent,omitempty"`
	// Defines an External Volume; implies no hostPath or persistent.
	External         *Volume_ExternalVolumeInfo `protobuf:"bytes,6,opt,name=external" json:"external,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Volume) Reset()                    { *m = Volume{} }
func (m *Volume) String() string            { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()               {}
func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Volume) GetMode() mesos.Volume_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return mesos.Volume_RW
}

func (m *Volume) GetContainerPath() string {
	if m != nil && m.ContainerPath != nil {
		return *m.ContainerPath
	}
	return ""
}

func (m *Volume) GetHostPath() string {
	if m != nil && m.HostPath != nil {
		return *m.HostPath
	}
	return ""
}

func (m *Volume) GetImage() *mesos.Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Volume) GetPersistent() *Volume_PersistentVolumeInfo {
	if m != nil {
		return m.Persistent
	}
	return nil
}

func (m *Volume) GetExternal() *Volume_ExternalVolumeInfo {
	if m != nil {
		return m.External
	}
	return nil
}

// Defining properties of persistent volumes
type Volume_PersistentVolumeInfo struct {
	Size             *uint64                              `protobuf:"varint,1,req,name=size" json:"size,omitempty"`
	Type             *mesos.Resource_DiskInfo_Source_Type `protobuf:"varint,2,opt,name=type,enum=mesos.Resource_DiskInfo_Source_Type" json:"type,omitempty"`
	Constraints      []*Constraint                        `protobuf:"bytes,3,rep,name=constraints" json:"constraints,omitempty"`
	MaxSize          *uint64                              `protobuf:"varint,4,opt,name=maxSize" json:"maxSize,omitempty"`
	XXX_unrecognized []byte                               `json:"-"`
}

func (m *Volume_PersistentVolumeInfo) Reset()                    { *m = Volume_PersistentVolumeInfo{} }
func (m *Volume_PersistentVolumeInfo) String() string            { return proto.CompactTextString(m) }
func (*Volume_PersistentVolumeInfo) ProtoMessage()               {}
func (*Volume_PersistentVolumeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 0} }

func (m *Volume_PersistentVolumeInfo) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *Volume_PersistentVolumeInfo) GetType() mesos.Resource_DiskInfo_Source_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return mesos.Resource_DiskInfo_Source_PATH
}

func (m *Volume_PersistentVolumeInfo) GetConstraints() []*Constraint {
	if m != nil {
		return m.Constraints
	}
	return nil
}

func (m *Volume_PersistentVolumeInfo) GetMaxSize() uint64 {
	if m != nil && m.MaxSize != nil {
		return *m.MaxSize
	}
	return 0
}

// Defining properties of external volumes
type Volume_ExternalVolumeInfo struct {
	Size             *uint64        `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	Name             *string        `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	Provider         *string        `protobuf:"bytes,3,req,name=provider" json:"provider,omitempty"`
	Options          []*mesos.Label `protobuf:"bytes,4,rep,name=options" json:"options,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Volume_ExternalVolumeInfo) Reset()                    { *m = Volume_ExternalVolumeInfo{} }
func (m *Volume_ExternalVolumeInfo) String() string            { return proto.CompactTextString(m) }
func (*Volume_ExternalVolumeInfo) ProtoMessage()               {}
func (*Volume_ExternalVolumeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 1} }

func (m *Volume_ExternalVolumeInfo) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *Volume_ExternalVolumeInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Volume_ExternalVolumeInfo) GetProvider() string {
	if m != nil && m.Provider != nil {
		return *m.Provider
	}
	return ""
}

func (m *Volume_ExternalVolumeInfo) GetOptions() []*mesos.Label {
	if m != nil {
		return m.Options
	}
	return nil
}

type EventSubscribers struct {
	CallbackUrls     []string `protobuf:"bytes,1,rep,name=callback_urls,json=callbackUrls" json:"callback_urls,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EventSubscribers) Reset()                    { *m = EventSubscribers{} }
func (m *EventSubscribers) String() string            { return proto.CompactTextString(m) }
func (*EventSubscribers) ProtoMessage()               {}
func (*EventSubscribers) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *EventSubscribers) GetCallbackUrls() []string {
	if m != nil {
		return m.CallbackUrls
	}
	return nil
}

type StorageVersion struct {
	Major *uint32 `protobuf:"varint,1,req,name=major" json:"major,omitempty"`
	Minor *uint32 `protobuf:"varint,2,req,name=minor" json:"minor,omitempty"`
	Patch *uint32 `protobuf:"varint,3,req,name=patch" json:"patch,omitempty"`
	// when we read old formats, we always assume legacy.
	Format           *StorageVersion_StorageFormat `protobuf:"varint,4,opt,name=format,enum=mesosphere.marathon.StorageVersion_StorageFormat,def=0" json:"format,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *StorageVersion) Reset()                    { *m = StorageVersion{} }
func (m *StorageVersion) String() string            { return proto.CompactTextString(m) }
func (*StorageVersion) ProtoMessage()               {}
func (*StorageVersion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

const Default_StorageVersion_Format StorageVersion_StorageFormat = StorageVersion_LEGACY

func (m *StorageVersion) GetMajor() uint32 {
	if m != nil && m.Major != nil {
		return *m.Major
	}
	return 0
}

func (m *StorageVersion) GetMinor() uint32 {
	if m != nil && m.Minor != nil {
		return *m.Minor
	}
	return 0
}

func (m *StorageVersion) GetPatch() uint32 {
	if m != nil && m.Patch != nil {
		return *m.Patch
	}
	return 0
}

func (m *StorageVersion) GetFormat() StorageVersion_StorageFormat {
	if m != nil && m.Format != nil {
		return *m.Format
	}
	return Default_StorageVersion_Format
}

type UpgradeStrategyDefinition struct {
	MinimumHealthCapacity *float64 `protobuf:"fixed64,1,req,name=minimumHealthCapacity" json:"minimumHealthCapacity,omitempty"`
	MaximumOverCapacity   *float64 `protobuf:"fixed64,2,opt,name=maximumOverCapacity,def=1" json:"maximumOverCapacity,omitempty"`
	XXX_unrecognized      []byte   `json:"-"`
}

func (m *UpgradeStrategyDefinition) Reset()                    { *m = UpgradeStrategyDefinition{} }
func (m *UpgradeStrategyDefinition) String() string            { return proto.CompactTextString(m) }
func (*UpgradeStrategyDefinition) ProtoMessage()               {}
func (*UpgradeStrategyDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

const Default_UpgradeStrategyDefinition_MaximumOverCapacity float64 = 1

func (m *UpgradeStrategyDefinition) GetMinimumHealthCapacity() float64 {
	if m != nil && m.MinimumHealthCapacity != nil {
		return *m.MinimumHealthCapacity
	}
	return 0
}

func (m *UpgradeStrategyDefinition) GetMaximumOverCapacity() float64 {
	if m != nil && m.MaximumOverCapacity != nil {
		return *m.MaximumOverCapacity
	}
	return Default_UpgradeStrategyDefinition_MaximumOverCapacity
}

type GroupDefinition struct {
	Id      *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Version *string `protobuf:"bytes,2,req,name=version" json:"version,omitempty"`
	// legacy: new storage uses AppReferences
	DeprecatedApps   []*ServiceDefinition            `protobuf:"bytes,3,rep,name=deprecated_apps,json=deprecatedApps" json:"deprecated_apps,omitempty"`
	DeprecatedPods   []*Json                         `protobuf:"bytes,8,rep,name=deprecated_pods,json=deprecatedPods" json:"deprecated_pods,omitempty"`
	Groups           []*GroupDefinition              `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
	Dependencies     []string                        `protobuf:"bytes,5,rep,name=dependencies" json:"dependencies,omitempty"`
	Apps             []*GroupDefinition_AppReference `protobuf:"bytes,6,rep,name=apps" json:"apps,omitempty"`
	Pods             []*GroupDefinition_AppReference `protobuf:"bytes,7,rep,name=pods" json:"pods,omitempty"`
	XXX_unrecognized []byte                          `json:"-"`
}

func (m *GroupDefinition) Reset()                    { *m = GroupDefinition{} }
func (m *GroupDefinition) String() string            { return proto.CompactTextString(m) }
func (*GroupDefinition) ProtoMessage()               {}
func (*GroupDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *GroupDefinition) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *GroupDefinition) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *GroupDefinition) GetDeprecatedApps() []*ServiceDefinition {
	if m != nil {
		return m.DeprecatedApps
	}
	return nil
}

func (m *GroupDefinition) GetDeprecatedPods() []*Json {
	if m != nil {
		return m.DeprecatedPods
	}
	return nil
}

func (m *GroupDefinition) GetGroups() []*GroupDefinition {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *GroupDefinition) GetDependencies() []string {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func (m *GroupDefinition) GetApps() []*GroupDefinition_AppReference {
	if m != nil {
		return m.Apps
	}
	return nil
}

func (m *GroupDefinition) GetPods() []*GroupDefinition_AppReference {
	if m != nil {
		return m.Pods
	}
	return nil
}

type GroupDefinition_AppReference struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Version          *string `protobuf:"bytes,2,req,name=version" json:"version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *GroupDefinition_AppReference) Reset()         { *m = GroupDefinition_AppReference{} }
func (m *GroupDefinition_AppReference) String() string { return proto.CompactTextString(m) }
func (*GroupDefinition_AppReference) ProtoMessage()    {}
func (*GroupDefinition_AppReference) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{18, 0}
}

func (m *GroupDefinition_AppReference) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *GroupDefinition_AppReference) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

type DeploymentPlanDefinition struct {
	Id        *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Timestamp *string `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// Note: deprecated_* can't be read by legacy persistent stores if they aren't set (since they were required)
	// They are no longer read by PersistenceStores
	DeprecatedOriginal *GroupDefinition `protobuf:"bytes,4,opt,name=deprecated_original,json=deprecatedOriginal" json:"deprecated_original,omitempty"`
	DeprecatedTarget   *GroupDefinition `protobuf:"bytes,5,opt,name=deprecated_target,json=deprecatedTarget" json:"deprecated_target,omitempty"`
	// The new original and target are required by PersistenceStores
	OriginalRootVersion *string `protobuf:"bytes,6,opt,name=original_root_version,json=originalRootVersion" json:"original_root_version,omitempty"`
	TargetRootVersion   *string `protobuf:"bytes,7,opt,name=target_root_version,json=targetRootVersion" json:"target_root_version,omitempty"`
	XXX_unrecognized    []byte  `json:"-"`
}

func (m *DeploymentPlanDefinition) Reset()                    { *m = DeploymentPlanDefinition{} }
func (m *DeploymentPlanDefinition) String() string            { return proto.CompactTextString(m) }
func (*DeploymentPlanDefinition) ProtoMessage()               {}
func (*DeploymentPlanDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *DeploymentPlanDefinition) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *DeploymentPlanDefinition) GetTimestamp() string {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return ""
}

func (m *DeploymentPlanDefinition) GetDeprecatedOriginal() *GroupDefinition {
	if m != nil {
		return m.DeprecatedOriginal
	}
	return nil
}

func (m *DeploymentPlanDefinition) GetDeprecatedTarget() *GroupDefinition {
	if m != nil {
		return m.DeprecatedTarget
	}
	return nil
}

func (m *DeploymentPlanDefinition) GetOriginalRootVersion() string {
	if m != nil && m.OriginalRootVersion != nil {
		return *m.OriginalRootVersion
	}
	return ""
}

func (m *DeploymentPlanDefinition) GetTargetRootVersion() string {
	if m != nil && m.TargetRootVersion != nil {
		return *m.TargetRootVersion
	}
	return ""
}

type TaskFailure struct {
	AppId            *string          `protobuf:"bytes,1,req,name=app_id,json=appId" json:"app_id,omitempty"`
	TaskId           *mesos.TaskID    `protobuf:"bytes,2,req,name=task_id,json=taskId" json:"task_id,omitempty"`
	State            *mesos.TaskState `protobuf:"varint,3,req,name=state,enum=mesos.TaskState" json:"state,omitempty"`
	Message          *string          `protobuf:"bytes,4,opt,name=message,def=" json:"message,omitempty"`
	Host             *string          `protobuf:"bytes,5,opt,name=host,def=" json:"host,omitempty"`
	Version          *string          `protobuf:"bytes,6,req,name=version" json:"version,omitempty"`
	Timestamp        *string          `protobuf:"bytes,7,req,name=timestamp" json:"timestamp,omitempty"`
	SlaveId          *mesos.SlaveID   `protobuf:"bytes,8,opt,name=slaveId" json:"slaveId,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *TaskFailure) Reset()                    { *m = TaskFailure{} }
func (m *TaskFailure) String() string            { return proto.CompactTextString(m) }
func (*TaskFailure) ProtoMessage()               {}
func (*TaskFailure) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *TaskFailure) GetAppId() string {
	if m != nil && m.AppId != nil {
		return *m.AppId
	}
	return ""
}

func (m *TaskFailure) GetTaskId() *mesos.TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *TaskFailure) GetState() mesos.TaskState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return mesos.TaskState_TASK_STAGING
}

func (m *TaskFailure) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *TaskFailure) GetHost() string {
	if m != nil && m.Host != nil {
		return *m.Host
	}
	return ""
}

func (m *TaskFailure) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *TaskFailure) GetTimestamp() string {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return ""
}

func (m *TaskFailure) GetSlaveId() *mesos.SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

// *
// Describes a state entry, a versioned (via a UUID) key/value pair.
// Copied from libmesos (src/messages/state.pro) to ensure
// compatibility with ZooKeeperState from libmesos.
type ZKStoreEntry struct {
	Name  *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Uuid  []byte  `protobuf:"bytes,2,req,name=uuid" json:"uuid,omitempty"`
	Value []byte  `protobuf:"bytes,3,req,name=value" json:"value,omitempty"`
	// This flag indicates, if the byte array in value is gzip compressed
	// Introduced in Marathon 0.12
	// Optional to be backward compatible
	Compressed       *bool  `protobuf:"varint,4,opt,name=compressed,def=0" json:"compressed,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ZKStoreEntry) Reset()                    { *m = ZKStoreEntry{} }
func (m *ZKStoreEntry) String() string            { return proto.CompactTextString(m) }
func (*ZKStoreEntry) ProtoMessage()               {}
func (*ZKStoreEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

const Default_ZKStoreEntry_Compressed bool = false

func (m *ZKStoreEntry) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ZKStoreEntry) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ZKStoreEntry) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ZKStoreEntry) GetCompressed() bool {
	if m != nil && m.Compressed != nil {
		return *m.Compressed
	}
	return Default_ZKStoreEntry_Compressed
}

type ResidencyDefinition struct {
	RelaunchEscalationTimeoutSeconds *int64                                `protobuf:"varint,1,opt,name=relaunchEscalationTimeoutSeconds" json:"relaunchEscalationTimeoutSeconds,omitempty"`
	TaskLostBehavior                 *ResidencyDefinition_TaskLostBehavior `protobuf:"varint,2,opt,name=taskLostBehavior,enum=mesosphere.marathon.ResidencyDefinition_TaskLostBehavior" json:"taskLostBehavior,omitempty"`
	XXX_unrecognized                 []byte                                `json:"-"`
}

func (m *ResidencyDefinition) Reset()                    { *m = ResidencyDefinition{} }
func (m *ResidencyDefinition) String() string            { return proto.CompactTextString(m) }
func (*ResidencyDefinition) ProtoMessage()               {}
func (*ResidencyDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ResidencyDefinition) GetRelaunchEscalationTimeoutSeconds() int64 {
	if m != nil && m.RelaunchEscalationTimeoutSeconds != nil {
		return *m.RelaunchEscalationTimeoutSeconds
	}
	return 0
}

func (m *ResidencyDefinition) GetTaskLostBehavior() ResidencyDefinition_TaskLostBehavior {
	if m != nil && m.TaskLostBehavior != nil {
		return *m.TaskLostBehavior
	}
	return ResidencyDefinition_RELAUNCH_AFTER_TIMEOUT
}

type Secret struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Source           *string `protobuf:"bytes,2,req,name=source" json:"source,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Secret) Reset()                    { *m = Secret{} }
func (m *Secret) String() string            { return proto.CompactTextString(m) }
func (*Secret) ProtoMessage()               {}
func (*Secret) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *Secret) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Secret) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

type EnvVarReference struct {
	Type             *EnvVarReference_Type `protobuf:"varint,1,req,name=type,enum=mesosphere.marathon.EnvVarReference_Type" json:"type,omitempty"`
	Name             *string               `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	SecretRef        *EnvVarSecretRef      `protobuf:"bytes,3,opt,name=secretRef" json:"secretRef,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *EnvVarReference) Reset()                    { *m = EnvVarReference{} }
func (m *EnvVarReference) String() string            { return proto.CompactTextString(m) }
func (*EnvVarReference) ProtoMessage()               {}
func (*EnvVarReference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *EnvVarReference) GetType() EnvVarReference_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return EnvVarReference_UNKNOWN
}

func (m *EnvVarReference) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EnvVarReference) GetSecretRef() *EnvVarSecretRef {
	if m != nil {
		return m.SecretRef
	}
	return nil
}

type EnvVarSecretRef struct {
	SecretId         *string `protobuf:"bytes,1,req,name=secretId" json:"secretId,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EnvVarSecretRef) Reset()                    { *m = EnvVarSecretRef{} }
func (m *EnvVarSecretRef) String() string            { return proto.CompactTextString(m) }
func (*EnvVarSecretRef) ProtoMessage()               {}
func (*EnvVarSecretRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *EnvVarSecretRef) GetSecretId() string {
	if m != nil && m.SecretId != nil {
		return *m.SecretId
	}
	return ""
}

func init() {
	proto.RegisterType((*Constraint)(nil), "mesosphere.marathon.Constraint")
	proto.RegisterType((*HealthCheckDefinition)(nil), "mesosphere.marathon.HealthCheckDefinition")
	proto.RegisterType((*ReadinessCheckDefinition)(nil), "mesosphere.marathon.ReadinessCheckDefinition")
	proto.RegisterType((*ObsoleteIpAddress)(nil), "mesosphere.marathon.ObsoleteIpAddress")
	proto.RegisterType((*ObsoleteDiscoveryInfo)(nil), "mesosphere.marathon.ObsoleteDiscoveryInfo")
	proto.RegisterType((*NetworkDefinition)(nil), "mesosphere.marathon.NetworkDefinition")
	proto.RegisterType((*ServiceDefinition)(nil), "mesosphere.marathon.ServiceDefinition")
	proto.RegisterType((*UnreachableStrategy)(nil), "mesosphere.marathon.UnreachableStrategy")
	proto.RegisterType((*Json)(nil), "mesosphere.marathon.Json")
	proto.RegisterType((*ResourceRoles)(nil), "mesosphere.marathon.ResourceRoles")
	proto.RegisterType((*MarathonTask)(nil), "mesosphere.marathon.MarathonTask")
	proto.RegisterType((*MarathonTask_Reservation)(nil), "mesosphere.marathon.MarathonTask.Reservation")
	proto.RegisterType((*MarathonTask_Reservation_State)(nil), "mesosphere.marathon.MarathonTask.Reservation.State")
	proto.RegisterType((*MarathonTask_Reservation_State_Timeout)(nil), "mesosphere.marathon.MarathonTask.Reservation.State.Timeout")
	proto.RegisterType((*MarathonApp)(nil), "mesosphere.marathon.MarathonApp")
	proto.RegisterType((*ContainerInfo)(nil), "mesosphere.marathon.ContainerInfo")
	proto.RegisterType((*ExtendedContainerInfo)(nil), "mesosphere.marathon.ExtendedContainerInfo")
	proto.RegisterType((*ExtendedContainerInfo_DockerInfo)(nil), "mesosphere.marathon.ExtendedContainerInfo.DockerInfo")
	proto.RegisterType((*ExtendedContainerInfo_DockerInfo_ObsoleteDockerPortMapping)(nil), "mesosphere.marathon.ExtendedContainerInfo.DockerInfo.ObsoleteDockerPortMapping")
	proto.RegisterType((*ExtendedContainerInfo_MesosDockerInfo)(nil), "mesosphere.marathon.ExtendedContainerInfo.MesosDockerInfo")
	proto.RegisterType((*ExtendedContainerInfo_MesosAppCInfo)(nil), "mesosphere.marathon.ExtendedContainerInfo.MesosAppCInfo")
	proto.RegisterType((*ExtendedContainerInfo_PortMapping)(nil), "mesosphere.marathon.ExtendedContainerInfo.PortMapping")
	proto.RegisterType((*Volume)(nil), "mesosphere.marathon.Volume")
	proto.RegisterType((*Volume_PersistentVolumeInfo)(nil), "mesosphere.marathon.Volume.PersistentVolumeInfo")
	proto.RegisterType((*Volume_ExternalVolumeInfo)(nil), "mesosphere.marathon.Volume.ExternalVolumeInfo")
	proto.RegisterType((*EventSubscribers)(nil), "mesosphere.marathon.EventSubscribers")
	proto.RegisterType((*StorageVersion)(nil), "mesosphere.marathon.StorageVersion")
	proto.RegisterType((*UpgradeStrategyDefinition)(nil), "mesosphere.marathon.UpgradeStrategyDefinition")
	proto.RegisterType((*GroupDefinition)(nil), "mesosphere.marathon.GroupDefinition")
	proto.RegisterType((*GroupDefinition_AppReference)(nil), "mesosphere.marathon.GroupDefinition.AppReference")
	proto.RegisterType((*DeploymentPlanDefinition)(nil), "mesosphere.marathon.DeploymentPlanDefinition")
	proto.RegisterType((*TaskFailure)(nil), "mesosphere.marathon.TaskFailure")
	proto.RegisterType((*ZKStoreEntry)(nil), "mesosphere.marathon.ZKStoreEntry")
	proto.RegisterType((*ResidencyDefinition)(nil), "mesosphere.marathon.ResidencyDefinition")
	proto.RegisterType((*Secret)(nil), "mesosphere.marathon.Secret")
	proto.RegisterType((*EnvVarReference)(nil), "mesosphere.marathon.EnvVarReference")
	proto.RegisterType((*EnvVarSecretRef)(nil), "mesosphere.marathon.EnvVarSecretRef")
	proto.RegisterEnum("mesosphere.marathon.KillSelection", KillSelection_name, KillSelection_value)
	proto.RegisterEnum("mesosphere.marathon.Constraint_Operator", Constraint_Operator_name, Constraint_Operator_value)
	proto.RegisterEnum("mesosphere.marathon.HealthCheckDefinition_Protocol", HealthCheckDefinition_Protocol_name, HealthCheckDefinition_Protocol_value)
	proto.RegisterEnum("mesosphere.marathon.ReadinessCheckDefinition_Protocol", ReadinessCheckDefinition_Protocol_name, ReadinessCheckDefinition_Protocol_value)
	proto.RegisterEnum("mesosphere.marathon.NetworkDefinition_Mode", NetworkDefinition_Mode_name, NetworkDefinition_Mode_value)
	proto.RegisterEnum("mesosphere.marathon.MarathonTask_Condition", MarathonTask_Condition_name, MarathonTask_Condition_value)
	proto.RegisterEnum("mesosphere.marathon.MarathonTask_Reservation_State_Type", MarathonTask_Reservation_State_Type_name, MarathonTask_Reservation_State_Type_value)
	proto.RegisterEnum("mesosphere.marathon.MarathonTask_Reservation_State_Timeout_Reason", MarathonTask_Reservation_State_Timeout_Reason_name, MarathonTask_Reservation_State_Timeout_Reason_value)
	proto.RegisterEnum("mesosphere.marathon.StorageVersion_StorageFormat", StorageVersion_StorageFormat_name, StorageVersion_StorageFormat_value)
	proto.RegisterEnum("mesosphere.marathon.ResidencyDefinition_TaskLostBehavior", ResidencyDefinition_TaskLostBehavior_name, ResidencyDefinition_TaskLostBehavior_value)
	proto.RegisterEnum("mesosphere.marathon.EnvVarReference_Type", EnvVarReference_Type_name, EnvVarReference_Type_value)
}

func init() { proto.RegisterFile("marathon.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 3690 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x7a, 0x5b, 0x6f, 0x1c, 0x47,
	0x76, 0xb0, 0x7a, 0xee, 0x3c, 0x73, 0x61, 0xb3, 0x28, 0xea, 0x6b, 0xd1, 0xf6, 0x9a, 0x6e, 0x6b,
	0xf5, 0x71, 0xb5, 0x2b, 0x7a, 0x38, 0x5a, 0xd9, 0x12, 0x73, 0x71, 0x86, 0xe4, 0x50, 0x1a, 0x8b,
	0xe4, 0xd0, 0x35, 0x43, 0xd9, 0x56, 0x02, 0x0c, 0x4a, 0xdd, 0xc5, 0x61, 0xaf, 0x7a, 0xba, 0x3b,
	0xd5, 0x35, 0x34, 0x99, 0xa7, 0x7d, 0xc8, 0x06, 0x8b, 0x00, 0xf9, 0x1b, 0xf9, 0x1f, 0x79, 0x08,
	0x90, 0x7d, 0xc8, 0x5b, 0x90, 0x0b, 0x92, 0x87, 0xbc, 0xe4, 0x21, 0x7f, 0x21, 0x40, 0x80, 0xa0,
	0xaa, 0xfa, 0x36, 0x64, 0x93, 0xa6, 0x95, 0xa7, 0x08, 0x02, 0xd1, 0x75, 0x6e, 0x55, 0x75, 0xce,
	0xa9, 0x73, 0x4e, 0x9d, 0x1a, 0x68, 0x4d, 0x09, 0x23, 0xfc, 0xd4, 0xf7, 0x36, 0x02, 0xe6, 0x73,
	0x1f, 0x2d, 0x4f, 0x69, 0xe8, 0x87, 0xc1, 0x29, 0x65, 0x74, 0x23, 0x46, 0xad, 0x2e, 0x49, 0xe0,
	0x67, 0xf2, 0xaf, 0xa2, 0x33, 0xff, 0x41, 0x03, 0xd8, 0xf1, 0xbd, 0x90, 0x33, 0xe2, 0x78, 0x1c,
	0xdd, 0x85, 0xf2, 0x89, 0x43, 0x5d, 0xdb, 0xd0, 0xd6, 0x0a, 0xeb, 0x0b, 0x58, 0x0d, 0xd0, 0x2e,
	0xd4, 0xfc, 0x80, 0x32, 0xc2, 0x7d, 0x66, 0x14, 0xd6, 0x0a, 0xeb, 0xad, 0xce, 0xfa, 0x46, 0x8e,
	0xfc, 0x8d, 0x54, 0xd0, 0xc6, 0x20, 0xa2, 0xc7, 0x09, 0xa7, 0x90, 0x7d, 0x46, 0xdc, 0x19, 0x35,
	0x8a, 0x6b, 0x9a, 0x90, 0x2d, 0x07, 0xe6, 0x08, 0x6a, 0x31, 0x2d, 0x02, 0xa8, 0x1c, 0x1f, 0xf6,
	0xbf, 0x3e, 0xee, 0xe9, 0x77, 0x50, 0x0d, 0x4a, 0xfb, 0xfd, 0x57, 0x3d, 0x5d, 0x43, 0x75, 0xa8,
	0xee, 0xec, 0x1f, 0x0f, 0x47, 0x3d, 0xac, 0x17, 0x50, 0x03, 0x6a, 0x2f, 0xf0, 0xe0, 0xf8, 0x68,
	0xbc, 0xfd, 0x9d, 0x5e, 0x54, 0x0c, 0x92, 0xac, 0x24, 0xc8, 0x0e, 0xba, 0xdf, 0x8e, 0x8f, 0x7a,
	0x58, 0x2f, 0x9b, 0xbf, 0x2e, 0xc3, 0xca, 0x4b, 0x4a, 0x5c, 0x7e, 0xba, 0x73, 0x4a, 0xad, 0x77,
	0xbb, 0xf4, 0xc4, 0xf1, 0x1c, 0xee, 0xf8, 0x1e, 0x1a, 0x40, 0x4d, 0xee, 0xdc, 0xf2, 0x5d, 0xb9,
	0xc9, 0x56, 0xe7, 0x49, 0xee, 0x5e, 0x72, 0xb9, 0x37, 0x8e, 0x22, 0x56, 0x9c, 0x08, 0x41, 0x1f,
	0xc2, 0x42, 0xe0, 0x33, 0xde, 0xf7, 0x6c, 0x7a, 0x6e, 0x14, 0xd6, 0xb4, 0xf5, 0x26, 0x4e, 0x01,
	0xa8, 0x03, 0x68, 0xc2, 0x88, 0x45, 0x8f, 0x28, 0x73, 0x7c, 0x7b, 0x48, 0x2d, 0xdf, 0xb3, 0x43,
	0xa9, 0x81, 0xe6, 0x56, 0x61, 0xf3, 0x29, 0xce, 0xc1, 0xa2, 0x5f, 0xc0, 0xa2, 0xe3, 0x71, 0xca,
	0xce, 0x88, 0x1b, 0x33, 0x94, 0x22, 0x86, 0x36, 0xbe, 0x8c, 0x42, 0x8f, 0xa0, 0xc5, 0x9d, 0x29,
	0xf5, 0x67, 0x3c, 0x26, 0x2e, 0x2b, 0xe2, 0x4e, 0x1b, 0x5f, 0xc2, 0xa0, 0x15, 0x28, 0x05, 0x84,
	0x9f, 0x1a, 0x15, 0x61, 0x81, 0x2d, 0xed, 0x33, 0x2c, 0x87, 0xe8, 0x39, 0xdc, 0x9b, 0x92, 0x73,
	0x61, 0x3d, 0x6a, 0xcd, 0xb8, 0x73, 0x46, 0xf7, 0x88, 0xe3, 0xce, 0x18, 0x0d, 0x8d, 0xaa, 0x14,
	0xa5, 0x3d, 0xc1, 0xd7, 0x10, 0xa0, 0x5f, 0x40, 0xd5, 0xf2, 0xa7, 0x53, 0xe2, 0xd9, 0x46, 0x6d,
	0x4d, 0x5b, 0xaf, 0x77, 0x90, 0xd2, 0xe6, 0xc6, 0x8e, 0x82, 0xf6, 0xbd, 0x13, 0x1f, 0xc7, 0x24,
	0xe8, 0xe7, 0xd0, 0x74, 0x26, 0x9e, 0xcf, 0xe8, 0x4b, 0xce, 0x83, 0xcd, 0xf3, 0x73, 0x63, 0x61,
	0x4d, 0x5b, 0xaf, 0x6d, 0x95, 0x4f, 0x88, 0x1b, 0x52, 0x3c, 0x8f, 0x43, 0x08, 0x4a, 0x42, 0x8f,
	0x06, 0x48, 0x9d, 0xca, 0x6f, 0xf4, 0x10, 0x1a, 0x36, 0x75, 0xc9, 0x45, 0xbc, 0xd5, 0x7a, 0xa2,
	0xc8, 0x39, 0x38, 0x5a, 0x85, 0x9a, 0xa0, 0x3f, 0x24, 0x53, 0x6a, 0x34, 0xa4, 0xbb, 0x25, 0x63,
	0x93, 0x42, 0x2d, 0x36, 0xa3, 0xf0, 0xb2, 0x97, 0xa3, 0xd1, 0x91, 0x7e, 0x07, 0x55, 0xa1, 0x38,
	0xda, 0x39, 0x8a, 0xdc, 0x6d, 0x70, 0x70, 0xd0, 0x3d, 0xdc, 0xd5, 0x0b, 0x68, 0x01, 0xca, 0x02,
	0x3f, 0xd4, 0x8b, 0xa8, 0x05, 0x70, 0xd0, 0x1b, 0x0e, 0x86, 0x63, 0xc9, 0x50, 0x42, 0x8b, 0x50,
	0x4f, 0xc7, 0x43, 0xbd, 0x8c, 0x9a, 0xb0, 0xa0, 0x00, 0x42, 0x4e, 0xc5, 0xfc, 0xab, 0x22, 0x18,
	0x98, 0x12, 0xdb, 0xf1, 0x68, 0x18, 0x5e, 0xf6, 0x42, 0x04, 0x25, 0x4f, 0xac, 0x4d, 0x93, 0x6b,
	0x93, 0xdf, 0x08, 0x67, 0x3c, 0x53, 0xf8, 0x51, 0xab, 0xf3, 0x79, 0xae, 0x67, 0x5e, 0x27, 0x34,
	0xcf, 0x39, 0x51, 0x64, 0x70, 0x75, 0xe4, 0x94, 0xb5, 0xb3, 0xba, 0x29, 0xcd, 0xeb, 0x06, 0x3d,
	0x84, 0x56, 0xec, 0x5f, 0x07, 0x8e, 0xeb, 0x3a, 0xca, 0x99, 0x4a, 0xf8, 0x12, 0x14, 0x3d, 0x80,
	0x66, 0xe4, 0x5a, 0x11, 0x59, 0x45, 0x92, 0xcd, 0x03, 0xd1, 0xe7, 0x70, 0xef, 0x94, 0xf3, 0x60,
	0xc8, 0x09, 0x9f, 0x85, 0x3b, 0xbe, 0x4d, 0xf7, 0x7c, 0x26, 0x56, 0x7f, 0x61, 0x54, 0xd7, 0x8a,
	0xeb, 0x4d, 0x7c, 0x0d, 0x16, 0x75, 0xe0, 0x6e, 0xc0, 0x68, 0x48, 0xd9, 0x19, 0xdd, 0x27, 0x21,
	0xc7, 0x34, 0x0c, 0x84, 0xeb, 0x49, 0x0f, 0xab, 0xe1, 0x5c, 0x9c, 0xf9, 0x71, 0xae, 0x55, 0x13,
	0xfb, 0x69, 0xe6, 0xdf, 0x6a, 0xb0, 0x34, 0x78, 0x1b, 0xfa, 0x2e, 0xe5, 0xb4, 0x1f, 0x74, 0x6d,
	0x9b, 0xd1, 0x30, 0x44, 0xf7, 0xa0, 0x32, 0x61, 0xfe, 0x2c, 0x08, 0x0d, 0x6d, 0xad, 0xb8, 0xbe,
	0x80, 0xa3, 0x11, 0x7a, 0x00, 0x15, 0x97, 0xbc, 0xa5, 0x6e, 0x68, 0x14, 0xd6, 0x8a, 0xeb, 0xf5,
	0x4e, 0x23, 0x72, 0xeb, 0x7d, 0x01, 0xc4, 0x11, 0x0e, 0x1d, 0x41, 0xd3, 0x76, 0x42, 0xcb, 0x3f,
	0xa3, 0xec, 0x42, 0x78, 0xba, 0xd4, 0x73, 0xbd, 0xf3, 0x28, 0xd7, 0x6e, 0xf1, 0xe4, 0xbb, 0x59,
	0x0e, 0x3c, 0x2f, 0x00, 0xad, 0x41, 0xdd, 0xa3, 0xfc, 0x7b, 0x9f, 0xbd, 0xcb, 0xd8, 0x27, 0x0b,
	0x32, 0xb7, 0x60, 0x25, 0x57, 0x12, 0xfa, 0x04, 0xca, 0xc2, 0x8e, 0x6a, 0x27, 0xf5, 0x4e, 0x3d,
	0x5a, 0xf1, 0x91, 0xcf, 0x38, 0x56, 0x18, 0xf3, 0xef, 0x34, 0x58, 0x3a, 0x54, 0xb2, 0x32, 0xce,
	0xf8, 0x25, 0x94, 0xa6, 0xbe, 0xad, 0x9c, 0xb1, 0xd5, 0xf9, 0x79, 0xee, 0xe2, 0xaf, 0x70, 0x6d,
	0x1c, 0xf8, 0x36, 0xc5, 0x92, 0x31, 0xf1, 0xe6, 0x42, 0xc6, 0x9b, 0x53, 0x05, 0x16, 0xaf, 0x57,
	0xa0, 0xf9, 0x0c, 0x4a, 0x42, 0x8e, 0x38, 0x74, 0xc7, 0x87, 0xaf, 0x0e, 0x07, 0xdf, 0x1c, 0xaa,
	0xd0, 0xff, 0x72, 0x30, 0x1c, 0xe9, 0x9a, 0x38, 0x52, 0x3b, 0x83, 0xc3, 0x51, 0xb7, 0x7f, 0x28,
	0x83, 0x3f, 0x40, 0x65, 0x1b, 0xf7, 0x77, 0x5f, 0xf4, 0xf4, 0xa2, 0xf9, 0x9f, 0x2d, 0x58, 0x1a,
	0x52, 0x76, 0xe6, 0x58, 0x34, 0xb3, 0x95, 0x16, 0x14, 0x9c, 0x38, 0x79, 0x15, 0x1c, 0x1b, 0x3d,
	0x80, 0xa2, 0x35, 0xb5, 0x65, 0xd2, 0xca, 0x0f, 0x4d, 0x02, 0x2d, 0x42, 0xb8, 0xe3, 0x85, 0x9c,
	0x78, 0x16, 0x15, 0xcb, 0x2d, 0x88, 0x10, 0x9e, 0x00, 0xd0, 0x63, 0x58, 0x60, 0x34, 0xf4, 0x67,
	0x4c, 0x60, 0x4b, 0x72, 0x33, 0x8b, 0x91, 0x24, 0x1c, 0xc1, 0x71, 0x4a, 0x21, 0x2c, 0x68, 0xd3,
	0xd0, 0x62, 0x4e, 0x20, 0x56, 0x24, 0xcf, 0xcf, 0x02, 0xce, 0x82, 0x44, 0x22, 0x54, 0x86, 0xaa,
	0xc8, 0x53, 0xa0, 0x06, 0xa8, 0x0b, 0x75, 0x2b, 0xc9, 0x9f, 0xa1, 0x3c, 0x21, 0xf5, 0xce, 0xc7,
	0x3f, 0x90, 0x67, 0x71, 0x96, 0x07, 0x7d, 0x08, 0x35, 0x7a, 0x2e, 0x22, 0xb4, 0xcf, 0x8c, 0x9a,
	0xd0, 0xc1, 0xd6, 0x1d, 0x9c, 0x40, 0xd0, 0xd7, 0x80, 0x06, 0xdb, 0xc3, 0xc1, 0x7e, 0x6f, 0xd4,
	0x1b, 0x5b, 0xbe, 0xc7, 0x89, 0xe3, 0x51, 0x26, 0xa3, 0x6b, 0xbd, 0x63, 0x5e, 0x37, 0x8f, 0xa2,
	0x92, 0xaa, 0x5a, 0x8a, 0xb9, 0x13, 0x30, 0xea, 0x40, 0xf5, 0x8c, 0xb2, 0x50, 0xec, 0xb3, 0x2e,
	0x53, 0x8a, 0xb1, 0xf9, 0xfc, 0x8b, 0xf6, 0xe3, 0xf6, 0xe6, 0xe3, 0xf6, 0xe6, 0xa8, 0xdd, 0xde,
	0x92, 0xff, 0x37, 0xda, 0xed, 0xf6, 0x1b, 0x1c, 0x13, 0xa2, 0x43, 0x68, 0x9c, 0xa6, 0xb9, 0x35,
	0x34, 0x1a, 0x72, 0xa3, 0x8f, 0x6e, 0x9f, 0x84, 0xf1, 0x1c, 0x3f, 0xfa, 0x09, 0x54, 0xdf, 0x12,
	0xeb, 0x9d, 0x7f, 0x72, 0x62, 0x34, 0xd7, 0xb4, 0xf5, 0xe2, 0x56, 0x69, 0xb3, 0xdd, 0x6e, 0xe3,
	0x18, 0x88, 0x1e, 0x41, 0x33, 0xfa, 0xdc, 0x23, 0x96, 0xd0, 0x4c, 0x6b, 0x4d, 0x5b, 0xd7, 0xb6,
	0x4a, 0x9b, 0x1b, 0x9b, 0x4f, 0xf1, 0x3c, 0x0a, 0x7d, 0x0b, 0x8b, 0xb3, 0x60, 0xc2, 0x88, 0x4d,
	0x87, 0x9c, 0x11, 0x4e, 0x27, 0x17, 0xc6, 0xa2, 0xd4, 0xcf, 0x46, 0xee, 0xf2, 0x8e, 0xe7, 0x69,
	0x33, 0x4b, 0xbc, 0x2c, 0x06, 0x99, 0x22, 0x71, 0x05, 0xd4, 0xb3, 0xa9, 0x67, 0x39, 0x34, 0x34,
	0x74, 0x19, 0x6d, 0xe6, 0x60, 0xc2, 0x0d, 0x43, 0xee, 0x33, 0x7a, 0xcc, 0xdc, 0xd0, 0x58, 0x92,
	0x04, 0x29, 0x40, 0xec, 0x83, 0xd1, 0x3f, 0x9d, 0x39, 0x8c, 0x8e, 0x95, 0xf7, 0xa0, 0x6c, 0xee,
	0x6c, 0x44, 0xb8, 0x23, 0xe9, 0x4b, 0x2f, 0x61, 0x21, 0xb5, 0xf0, 0xf2, 0x0d, 0x31, 0xa9, 0x77,
	0xce, 0xc5, 0xfc, 0xf6, 0xbc, 0xa5, 0x53, 0x66, 0xb4, 0x9e, 0x1c, 0xe3, 0xbb, 0xd2, 0x4e, 0x7a,
	0x1c, 0x55, 0x08, 0x23, 0x53, 0xca, 0x29, 0x4b, 0x62, 0xe1, 0x67, 0xa2, 0x06, 0x3d, 0xdf, 0x27,
	0x33, 0xcf, 0x3a, 0xdd, 0x15, 0xb9, 0xd8, 0x58, 0x91, 0xe6, 0xa8, 0x3e, 0xf9, 0xbc, 0x2d, 0xfe,
	0xe1, 0x4b, 0x68, 0xf4, 0x2d, 0xac, 0x10, 0xcb, 0xa2, 0x01, 0xa7, 0x76, 0x72, 0x8e, 0x7c, 0x97,
	0x86, 0xc6, 0xbd, 0x1b, 0x5c, 0x72, 0x8e, 0x12, 0xe7, 0x0b, 0x40, 0x0f, 0x61, 0xd1, 0x25, 0x21,
	0x1f, 0x87, 0x16, 0x71, 0x1d, 0x6f, 0x32, 0x26, 0xdc, 0xf8, 0x7f, 0x62, 0x2d, 0xb8, 0x29, 0xc0,
	0x43, 0x05, 0xed, 0x72, 0xb4, 0x09, 0x2b, 0x92, 0xce, 0xf2, 0xbd, 0x13, 0x67, 0x32, 0xb6, 0x4e,
	0x89, 0x37, 0xa1, 0x82, 0xda, 0x90, 0xd4, 0x48, 0x20, 0x77, 0x24, 0x6e, 0x47, 0xa2, 0xba, 0x1c,
	0x1d, 0x67, 0x0e, 0x91, 0x13, 0x67, 0x11, 0xe3, 0xbe, 0x5c, 0xf1, 0xc3, 0x1b, 0xc3, 0x7e, 0x92,
	0x73, 0xd2, 0x83, 0x94, 0xa6, 0xa1, 0x3d, 0x19, 0x63, 0x1c, 0xe1, 0x09, 0x17, 0xc6, 0xaa, 0x94,
	0xb6, 0x7e, 0xdd, 0xfe, 0x15, 0x55, 0xc6, 0xd9, 0x52, 0x56, 0xf4, 0x14, 0x16, 0x85, 0x73, 0xa4,
	0xc8, 0xd0, 0xf8, 0xe0, 0x6a, 0x36, 0xb8, 0x4c, 0x83, 0x1c, 0x30, 0xd8, 0x35, 0x55, 0x85, 0xf1,
	0xa1, 0xe4, 0x7f, 0xfc, 0xa3, 0x4a, 0x11, 0x7c, 0xad, 0x38, 0xf4, 0x14, 0xaa, 0x21, 0xb5, 0x18,
	0xe5, 0xa1, 0xf1, 0x91, 0x94, 0xfc, 0x41, 0xae, 0xe4, 0xa1, 0xa4, 0xc1, 0x31, 0x2d, 0x3a, 0x02,
	0x9d, 0x7a, 0x67, 0xaf, 0x09, 0xc3, 0xf4, 0x84, 0x32, 0x2a, 0x23, 0xf5, 0x4f, 0x24, 0xff, 0x83,
	0x7c, 0xc7, 0x9e, 0x27, 0xc6, 0x57, 0xb8, 0x51, 0x1b, 0x96, 0x39, 0x09, 0xdf, 0xbd, 0x72, 0x5c,
	0xf7, 0x45, 0x5a, 0x83, 0x1b, 0x1f, 0x4b, 0xd3, 0xe7, 0xa1, 0xd0, 0x1b, 0x58, 0x9e, 0x79, 0x8c,
	0x12, 0xeb, 0x94, 0xbc, 0x75, 0xd3, 0x08, 0xb1, 0x76, 0x83, 0xb9, 0x8e, 0xaf, 0xd2, 0xe3, 0x3c,
	0x21, 0xe8, 0x1b, 0x68, 0xbe, 0x73, 0x5c, 0x77, 0x48, 0x5d, 0x6a, 0x49, 0xb5, 0x7f, 0x22, 0x93,
	0x71, 0xfe, 0x21, 0x78, 0x95, 0xa5, 0xdc, 0x6a, 0x7e, 0xe7, 0xcf, 0xbc, 0x09, 0x0d, 0xf9, 0x9e,
	0xc3, 0x42, 0x8e, 0xe7, 0xe5, 0xa0, 0x6d, 0xa8, 0x45, 0xd5, 0x43, 0x68, 0x98, 0x52, 0x61, 0x0f,
	0x6f, 0x97, 0xe0, 0x71, 0xc2, 0x67, 0xfe, 0x56, 0x83, 0xe5, 0x9c, 0x9d, 0xa0, 0x2f, 0xe0, 0xae,
	0xe3, 0x11, 0x4b, 0x5c, 0x08, 0xba, 0x27, 0x9c, 0xb2, 0xb8, 0x2a, 0x17, 0x85, 0x44, 0x69, 0xab,
	0xf8, 0xbc, 0xdd, 0xc6, 0xb9, 0x04, 0xe8, 0x19, 0x2c, 0xd3, 0xf3, 0x40, 0xac, 0x7a, 0x8e, 0xaf,
	0x20, 0xf9, 0x2a, 0x9f, 0xb7, 0x7f, 0xf9, 0xac, 0xdd, 0xc6, 0x79, 0x24, 0xe6, 0x2a, 0x94, 0xbe,
	0x0a, 0x55, 0x01, 0xfd, 0xab, 0xd0, 0xf7, 0xa2, 0x54, 0x2f, 0xbf, 0xcd, 0x4f, 0xa1, 0x39, 0x1f,
	0x07, 0x10, 0x94, 0x98, 0xef, 0xd2, 0xa8, 0xb4, 0x93, 0xdf, 0xe6, 0xef, 0xea, 0xd0, 0x38, 0x88,
	0x36, 0x3d, 0x22, 0xe1, 0xbb, 0x2b, 0x25, 0xc3, 0xa7, 0xd0, 0x4c, 0x4e, 0xf8, 0xa9, 0x1f, 0xf2,
	0xa8, 0xaa, 0x69, 0xc4, 0xc0, 0x97, 0x7e, 0xc8, 0xd3, 0x14, 0x5e, 0x9c, 0x4f, 0xe1, 0xcb, 0x09,
	0x2b, 0xe1, 0x9c, 0x39, 0x6f, 0x67, 0x3c, 0xa9, 0x19, 0xe2, 0xc8, 0xd9, 0x8d, 0x11, 0x38, 0x89,
	0x24, 0x09, 0x28, 0x44, 0x1f, 0x88, 0x1c, 0x40, 0x26, 0xd4, 0x16, 0x61, 0xa8, 0x2c, 0x7d, 0xb1,
	0xa6, 0x00, 0x5d, 0x8e, 0x3e, 0x02, 0x08, 0x39, 0x61, 0x5c, 0x61, 0x2b, 0x12, 0xbb, 0x10, 0x41,
	0xba, 0x1c, 0xfd, 0x21, 0x24, 0x91, 0x65, 0x1c, 0xca, 0xaa, 0x9a, 0xc6, 0x75, 0xc4, 0x52, 0x34,
	0xb9, 0xd8, 0xb1, 0x2a, 0xb8, 0xb1, 0x1e, 0xd3, 0x0e, 0x23, 0xd2, 0x6c, 0x36, 0xaf, 0xdd, 0x36,
	0x9b, 0xff, 0x0c, 0x2a, 0x6a, 0x2a, 0x79, 0x95, 0xcb, 0x9d, 0x28, 0x22, 0x40, 0xcf, 0x41, 0x4f,
	0x97, 0xe7, 0x92, 0x33, 0xda, 0xb7, 0xa3, 0xea, 0xa3, 0x15, 0x31, 0x0d, 0x25, 0x74, 0x17, 0x2f,
	0x26, 0x4b, 0x53, 0x64, 0xe8, 0xcb, 0xcc, 0xce, 0x12, 0x6f, 0xae, 0xcb, 0x9d, 0xc5, 0x45, 0x5d,
	0xe4, 0xbf, 0x32, 0x7f, 0x25, 0xf3, 0x44, 0xc0, 0x10, 0x0d, 0xa0, 0xae, 0x2e, 0x0d, 0x44, 0x1e,
	0xae, 0x86, 0x9c, 0x36, 0x3f, 0xa6, 0x65, 0x9d, 0x43, 0x84, 0xdb, 0x98, 0x09, 0x67, 0x25, 0xa0,
	0xbe, 0xcc, 0xb0, 0xb6, 0x0a, 0x91, 0xcd, 0x1b, 0x0a, 0xe7, 0x39, 0x71, 0x3b, 0x31, 0x0b, 0x4e,
	0xb9, 0x57, 0xff, 0xad, 0x04, 0xf5, 0xcc, 0x3c, 0x68, 0x1d, 0x74, 0xd7, 0xb7, 0x88, 0x3b, 0x3e,
	0xf3, 0xdd, 0xd9, 0x94, 0x8e, 0x1d, 0x3b, 0xbe, 0x9c, 0xb4, 0x24, 0xfc, 0xb5, 0x04, 0xf7, 0xed,
	0x10, 0xf5, 0xa1, 0x2c, 0x74, 0x4b, 0xa3, 0xfa, 0xf6, 0xc9, 0x8f, 0xda, 0xcf, 0x86, 0x30, 0x0f,
	0xc5, 0x4a, 0xc2, 0xea, 0x3f, 0x15, 0xa1, 0x2c, 0x01, 0x68, 0x1f, 0x4a, 0xfc, 0x22, 0xa0, 0x51,
	0x73, 0xe4, 0xd9, 0x7b, 0xc8, 0xdc, 0x18, 0x5d, 0x04, 0x14, 0x4b, 0x29, 0xe8, 0x18, 0xaa, 0xd1,
	0x9d, 0x50, 0x9e, 0xa3, 0x7a, 0xe7, 0xf7, 0xde, 0x4b, 0xa0, 0x12, 0x81, 0x63, 0x59, 0xab, 0xff,
	0xae, 0x41, 0x35, 0x02, 0xaa, 0xea, 0xdd, 0xe1, 0x0e, 0xe1, 0x54, 0x9d, 0xe3, 0x22, 0x4e, 0x01,
	0xe2, 0xb6, 0x6b, 0x53, 0x62, 0xbb, 0x8e, 0xa7, 0xd4, 0x54, 0xc4, 0xc9, 0x18, 0xbd, 0x81, 0x0a,
	0xa3, 0x44, 0x84, 0x91, 0xa2, 0xdc, 0xec, 0xf6, 0xff, 0x62, 0x6d, 0x22, 0x17, 0x86, 0xbe, 0x87,
	0x23, 0x89, 0xe6, 0x97, 0x50, 0x51, 0x10, 0xf4, 0x11, 0xdc, 0xc7, 0xd4, 0x95, 0x85, 0x4f, 0x4f,
	0x54, 0x24, 0x92, 0x39, 0xe2, 0xd2, 0x35, 0x74, 0x0f, 0x50, 0x46, 0x68, 0x0c, 0x2f, 0x98, 0x7b,
	0x50, 0x12, 0x7a, 0x44, 0x55, 0x28, 0x1e, 0xd2, 0xef, 0x75, 0x0d, 0x35, 0xa0, 0xa6, 0xca, 0x27,
	0x6a, 0xeb, 0x05, 0x71, 0x35, 0x1a, 0xce, 0x42, 0x59, 0x3d, 0xda, 0x7a, 0x51, 0x5c, 0xa0, 0x5e,
	0x10, 0xf6, 0x96, 0x4c, 0xa8, 0x6a, 0x85, 0x1d, 0x7b, 0xef, 0x3c, 0xff, 0x7b, 0x4f, 0x2f, 0x9b,
	0xff, 0xac, 0xc1, 0x42, 0xe2, 0x77, 0x02, 0xd5, 0xf7, 0xce, 0x88, 0xeb, 0xd8, 0xfa, 0x1d, 0x21,
	0x51, 0x4d, 0x4d, 0xed, 0xa8, 0xf1, 0xc1, 0xa8, 0x50, 0x9a, 0x6a, 0x7c, 0xf4, 0x18, 0xf3, 0x99,
	0x6a, 0xb2, 0xed, 0x11, 0xc7, 0xa5, 0xb6, 0x5e, 0x12, 0x1c, 0x7b, 0x8e, 0xe7, 0x84, 0x62, 0x0d,
	0x65, 0x81, 0x11, 0xa9, 0x88, 0xda, 0x7a, 0x45, 0x70, 0x8b, 0x6f, 0xc7, 0x9b, 0xe8, 0x55, 0xd9,
	0xbc, 0xf3, 0x43, 0xae, 0xd7, 0x04, 0x18, 0xcf, 0x3c, 0x4f, 0x80, 0x17, 0xc4, 0x60, 0xc8, 0xc9,
	0x44, 0x0c, 0x40, 0x88, 0x1a, 0x8a, 0xd0, 0x25, 0x46, 0x75, 0xb4, 0x08, 0xf5, 0x4c, 0x86, 0xd1,
	0x1b, 0x42, 0xc4, 0x0b, 0xdf, 0xa3, 0x7a, 0x33, 0xbb, 0x9b, 0x96, 0x18, 0xec, 0x32, 0x3f, 0x08,
	0xa8, 0xad, 0x2f, 0x9a, 0x6f, 0xa0, 0x1e, 0x1b, 0xa7, 0x1b, 0x04, 0xb9, 0x4d, 0x95, 0x2f, 0xa0,
	0x2c, 0x52, 0x79, 0x7c, 0x8d, 0xff, 0xe4, 0x07, 0x2d, 0x8c, 0x15, 0xbd, 0xd9, 0x85, 0xe6, 0x5c,
	0x51, 0x8c, 0xee, 0x41, 0xd9, 0x99, 0x92, 0x89, 0x3a, 0x18, 0x8d, 0xad, 0x3b, 0x58, 0x0d, 0x91,
	0x01, 0x55, 0x3f, 0x50, 0xa5, 0x96, 0x98, 0xa3, 0x81, 0xe3, 0xa1, 0xf9, 0xd7, 0x0d, 0x58, 0xc9,
	0x2d, 0xb0, 0xd1, 0xe3, 0xb9, 0x33, 0x76, 0x3f, 0xb9, 0x97, 0x66, 0x68, 0xb2, 0x87, 0xe8, 0x29,
	0x54, 0x55, 0x2c, 0x88, 0xb7, 0x91, 0x5f, 0x33, 0xa9, 0xc0, 0x80, 0x63, 0x5a, 0xf4, 0xc7, 0xd0,
	0x14, 0x79, 0x69, 0x3c, 0x25, 0x41, 0xe0, 0x78, 0x13, 0x75, 0xdf, 0xac, 0x5f, 0xd3, 0x55, 0xca,
	0x5d, 0xa8, 0x2c, 0x17, 0x0f, 0x14, 0x3b, 0x6e, 0x04, 0xe9, 0x20, 0x44, 0x07, 0x50, 0xb1, 0x7d,
	0xeb, 0x1d, 0x65, 0x51, 0xcf, 0xe3, 0xe9, 0x8f, 0x90, 0xba, 0x2b, 0x19, 0x65, 0xa8, 0x8e, 0x84,
	0xa0, 0x3f, 0x81, 0xba, 0xe4, 0x57, 0x28, 0xd9, 0xf7, 0xa8, 0x77, 0xb6, 0x7e, 0x84, 0xcc, 0x83,
	0x94, 0x5b, 0x0a, 0xce, 0x8a, 0x43, 0xaf, 0x61, 0x41, 0x0e, 0xbb, 0x41, 0xb0, 0x23, 0xb3, 0x6a,
	0xfd, 0x9a, 0xc0, 0x76, 0x83, 0x6c, 0xc1, 0xab, 0x6e, 0x47, 0x89, 0xa8, 0xd5, 0xff, 0x28, 0x01,
	0xa4, 0x73, 0x8a, 0xaa, 0x20, 0x75, 0x91, 0x85, 0xd8, 0x41, 0xbe, 0xcd, 0xe4, 0xbd, 0x28, 0x79,
	0x45, 0xfd, 0xbd, 0xff, 0x9f, 0x6b, 0xf8, 0x54, 0x60, 0x9c, 0xd4, 0xb6, 0x64, 0x3f, 0x24, 0x4d,
	0x8b, 0x11, 0x18, 0xfd, 0x46, 0x83, 0x7b, 0x89, 0xe8, 0x79, 0x53, 0xab, 0xa6, 0xcb, 0xe0, 0xbd,
	0x8c, 0x92, 0x76, 0xaa, 0x24, 0x28, 0xeb, 0x03, 0x77, 0xe3, 0xe9, 0x8e, 0xb2, 0xbe, 0xf0, 0x53,
	0x80, 0x80, 0x39, 0x67, 0x8e, 0x4b, 0x27, 0xd4, 0x96, 0xb6, 0x4b, 0xee, 0xa5, 0x19, 0x04, 0x6a,
	0x03, 0x04, 0xf1, 0xb5, 0x31, 0x34, 0xca, 0xd7, 0xdc, 0x27, 0x33, 0x34, 0x22, 0x15, 0x9e, 0xf8,
	0xcc, 0xa2, 0xe3, 0x60, 0xe6, 0xba, 0x63, 0xa5, 0xdb, 0x8a, 0x6c, 0x02, 0xb6, 0x24, 0xfc, 0x68,
	0xe6, 0xba, 0x7d, 0x01, 0x5d, 0xfd, 0x57, 0x0d, 0xee, 0x5f, 0xbb, 0x6c, 0x51, 0x55, 0x89, 0x52,
	0x4e, 0xea, 0x48, 0x86, 0x87, 0x26, 0xae, 0x09, 0x80, 0xa0, 0x41, 0x3f, 0x85, 0x56, 0x72, 0xdf,
	0x55, 0x14, 0x05, 0xd9, 0x02, 0x6a, 0x26, 0x50, 0x49, 0xb6, 0x9a, 0x69, 0xcf, 0x16, 0xa3, 0xb6,
	0x69, 0xa6, 0xcd, 0xea, 0xa5, 0xed, 0xba, 0xcb, 0x0d, 0xb0, 0xf2, 0x0d, 0x1d, 0xc4, 0x07, 0xd0,
	0x08, 0x55, 0x17, 0x4b, 0x4d, 0x6d, 0xab, 0x86, 0x7b, 0x1b, 0xd7, 0x23, 0xb0, 0x98, 0x7b, 0xf5,
	0xcf, 0x35, 0x58, 0xbc, 0xe4, 0xe0, 0xd7, 0x38, 0xdb, 0x26, 0x80, 0xc5, 0xa8, 0x4d, 0x3d, 0xee,
	0x10, 0x37, 0x4a, 0xb9, 0x71, 0x4d, 0xb6, 0x93, 0x20, 0x70, 0x86, 0x28, 0x57, 0xc9, 0xc5, 0x5c,
	0x25, 0xff, 0x46, 0x83, 0xe6, 0xdc, 0x59, 0xb8, 0x66, 0x11, 0xaa, 0xa4, 0x56, 0x75, 0xb3, 0xea,
	0xc2, 0xdd, 0xa2, 0x17, 0x98, 0xbb, 0x8e, 0x52, 0xee, 0x3a, 0xfe, 0x5e, 0x83, 0xfa, 0xff, 0x4d,
	0xf3, 0x56, 0xf2, 0xcc, 0x6b, 0xfe, 0x77, 0x09, 0x2a, 0x2a, 0x78, 0xa3, 0x87, 0x51, 0x2f, 0x56,
	0x15, 0x24, 0x71, 0x71, 0xab, 0x90, 0xd9, 0x96, 0xeb, 0xfc, 0xae, 0x08, 0x3f, 0x8d, 0x2c, 0x90,
	0xd9, 0x15, 0xe1, 0xa7, 0xa9, 0x66, 0x04, 0x85, 0x32, 0x88, 0xd2, 0x8c, 0x40, 0x9a, 0xb1, 0xf1,
	0x54, 0xb4, 0x8d, 0x77, 0x20, 0x75, 0x1c, 0x9b, 0xf2, 0x08, 0x20, 0x10, 0xa5, 0x7e, 0xc8, 0xa9,
	0xc7, 0xa3, 0xd0, 0xd9, 0xbe, 0x21, 0xfb, 0x6c, 0x1c, 0x25, 0xd4, 0x51, 0x9d, 0x2a, 0x42, 0x66,
	0x46, 0x06, 0xfa, 0x0a, 0x6a, 0xf4, 0x9c, 0x53, 0xe6, 0x11, 0x57, 0xaa, 0xe3, 0xba, 0xe6, 0x5a,
	0x24, 0xaf, 0x17, 0xd1, 0x66, 0xa4, 0x25, 0xfc, 0xab, 0x7f, 0xa3, 0xc1, 0xdd, 0xbc, 0x09, 0x85,
	0xc5, 0x42, 0xe7, 0xcf, 0x94, 0x5b, 0x96, 0xb0, 0xfc, 0x46, 0xcf, 0xa2, 0xa4, 0xab, 0x62, 0xef,
	0x83, 0x4b, 0x2d, 0xdc, 0x8d, 0x5d, 0x27, 0x94, 0xb7, 0x87, 0x8d, 0xa1, 0x1a, 0x67, 0xf2, 0xef,
	0xa5, 0xd6, 0x6c, 0xf1, 0x3d, 0x5a, 0xb3, 0x06, 0x54, 0xa7, 0xe4, 0x7c, 0x28, 0xd6, 0x54, 0x92,
	0x4f, 0x25, 0xf1, 0x70, 0xf5, 0xd7, 0x1a, 0xa0, 0xab, 0x9b, 0xcc, 0xec, 0x40, 0x4b, 0x76, 0x90,
	0xf6, 0xd9, 0x0b, 0x89, 0x1f, 0x2a, 0xbf, 0x3d, 0x73, 0x6c, 0x99, 0x89, 0x0b, 0x91, 0xdf, 0xca,
	0x31, 0x7a, 0x98, 0x96, 0x26, 0xa5, 0x1c, 0x27, 0x4d, 0x0a, 0x95, 0x2f, 0x40, 0xef, 0x9d, 0x51,
	0x8f, 0x0f, 0x67, 0x6f, 0x43, 0x8b, 0x39, 0x6f, 0x45, 0xe8, 0xfd, 0x14, 0x9a, 0x16, 0x71, 0xdd,
	0xb7, 0xc4, 0x7a, 0x37, 0x9e, 0x31, 0x37, 0xbe, 0x82, 0x34, 0x62, 0xe0, 0x31, 0x73, 0x43, 0xf3,
	0x5f, 0x34, 0x68, 0x0d, 0xb9, 0xcf, 0xc8, 0x84, 0xbe, 0x8e, 0x2e, 0x84, 0x77, 0xa1, 0x3c, 0x25,
	0xbf, 0xf2, 0x99, 0x54, 0x7d, 0x13, 0xab, 0x81, 0x84, 0x3a, 0x5e, 0xf4, 0x7c, 0x2c, 0xa0, 0x62,
	0x20, 0x6f, 0xd1, 0x84, 0x5b, 0xa7, 0x51, 0xcf, 0x5d, 0x0d, 0xd0, 0xd7, 0x50, 0x39, 0xf1, 0xd9,
	0x94, 0x70, 0xa9, 0xa9, 0x56, 0x67, 0x33, 0xbf, 0x41, 0x34, 0x37, 0x6d, 0x3c, 0xdc, 0x93, 0x8c,
	0x5b, 0x95, 0xfd, 0xde, 0x8b, 0xee, 0xce, 0x77, 0x38, 0x12, 0x64, 0x76, 0xa0, 0x39, 0x47, 0x20,
	0x2a, 0x57, 0x45, 0xa2, 0xdf, 0x41, 0x2b, 0xb0, 0x74, 0xd4, 0xc3, 0xc3, 0xfe, 0x70, 0xd4, 0x3b,
	0xdc, 0xe9, 0x8d, 0x87, 0xa3, 0x01, 0xee, 0xe9, 0x9a, 0xf9, 0x17, 0x1a, 0xdc, 0xbf, 0xb6, 0xc1,
	0x8b, 0x7e, 0x09, 0x2b, 0x53, 0xc7, 0x73, 0xa6, 0xb3, 0x69, 0xd4, 0xa3, 0x26, 0x01, 0xb1, 0x1c,
	0x7e, 0x21, 0xb7, 0xad, 0xe1, 0x7c, 0x24, 0x7a, 0x02, 0xcb, 0x53, 0x72, 0x2e, 0x10, 0x83, 0x33,
	0xca, 0x12, 0x9e, 0x82, 0xec, 0x48, 0x6b, 0x9b, 0x38, 0x0f, 0x6b, 0xfe, 0x57, 0x11, 0x16, 0x5f,
	0x30, 0x7f, 0x16, 0xdc, 0xf0, 0xce, 0x61, 0xa4, 0x57, 0x77, 0xe5, 0x1c, 0xc9, 0x05, 0x7d, 0x00,
	0x8b, 0x36, 0x0d, 0x18, 0xb5, 0x88, 0x6c, 0x1b, 0x04, 0x41, 0xec, 0xbf, 0x0f, 0xaf, 0xe9, 0xbb,
	0x5d, 0x7a, 0x52, 0xc1, 0xad, 0x94, 0xbd, 0x1b, 0x04, 0x21, 0xda, 0x9e, 0x13, 0x18, 0xf8, 0x76,
	0x68, 0xd4, 0xa4, 0xc0, 0xfb, 0xb9, 0x02, 0xbf, 0x0a, 0xe7, 0x65, 0x1c, 0xf9, 0x76, 0x88, 0x7e,
	0x3f, 0x79, 0x75, 0x2b, 0xdd, 0xd0, 0xc3, 0xbb, 0xb4, 0xe9, 0xe4, 0x6d, 0xee, 0x72, 0x2f, 0xbd,
	0x9c, 0xd3, 0x4b, 0xef, 0x41, 0x49, 0xee, 0x55, 0x95, 0xbc, 0x9b, 0xb7, 0x91, 0xbf, 0xd1, 0x0d,
	0x82, 0xb4, 0x61, 0x28, 0xd9, 0x85, 0x18, 0xb9, 0xc3, 0xea, 0x7b, 0x8b, 0x11, 0xec, 0xab, 0xcf,
	0xa0, 0x91, 0x85, 0xde, 0xde, 0x7c, 0xe6, 0x3f, 0x16, 0xc0, 0xd8, 0xa5, 0x81, 0xeb, 0x5f, 0x4c,
	0xa9, 0xc7, 0x8f, 0x5c, 0xe2, 0xdd, 0xe0, 0x05, 0x1f, 0xc2, 0x82, 0xb8, 0x20, 0x87, 0x9c, 0x4c,
	0x83, 0x28, 0xda, 0xa7, 0x00, 0x74, 0x0c, 0xcb, 0x19, 0xc3, 0xf9, 0xcc, 0x99, 0x38, 0x22, 0x06,
	0xab, 0xe0, 0x7f, 0x3b, 0x0b, 0xa0, 0x54, 0xc0, 0x20, 0xe2, 0x47, 0x5f, 0xc3, 0x52, 0x46, 0x2c,
	0x27, 0x6c, 0x42, 0xe3, 0x44, 0x71, 0x3b, 0xa1, 0x7a, 0xca, 0x3e, 0x92, 0xdc, 0xa8, 0x03, 0x2b,
	0xf1, 0xf2, 0xc6, 0xcc, 0xf7, 0xf9, 0x38, 0x56, 0x8e, 0xfc, 0xdd, 0x02, 0x5e, 0x8e, 0x91, 0xd8,
	0xf7, 0x79, 0x1c, 0x77, 0x36, 0x60, 0x59, 0xcd, 0x3d, 0xcf, 0x51, 0x95, 0x1c, 0x4b, 0x0a, 0x95,
	0xa1, 0x37, 0x7f, 0x5b, 0x80, 0xba, 0xb8, 0xef, 0x45, 0xbf, 0x64, 0x40, 0x2b, 0x50, 0x21, 0x41,
	0x30, 0x4e, 0xf4, 0x59, 0x26, 0x41, 0xd0, 0xb7, 0x45, 0x08, 0x15, 0xf7, 0xc1, 0xb1, 0x13, 0x3f,
	0x22, 0x36, 0x33, 0x0d, 0xae, 0xfe, 0x2e, 0xae, 0x08, 0xac, 0xa4, 0x8b, 0x5a, 0x31, 0x2a, 0x71,
	0xeb, 0x97, 0xda, 0x60, 0x71, 0x9f, 0x05, 0xad, 0x42, 0x75, 0x4a, 0xc3, 0x30, 0xce, 0xba, 0x0b,
	0x5b, 0x77, 0x70, 0x0c, 0x40, 0x77, 0xa1, 0x24, 0x1b, 0x8e, 0xe5, 0x08, 0x21, 0x47, 0x59, 0xdf,
	0xa8, 0xcc, 0x1f, 0xed, 0x39, 0x73, 0x57, 0x25, 0x2e, 0x63, 0xee, 0x75, 0xa8, 0xc6, 0x5d, 0xb6,
	0x5a, 0x6e, 0x97, 0x2d, 0x46, 0x9b, 0x21, 0x34, 0xde, 0xbc, 0x12, 0xf1, 0x91, 0xf6, 0x3c, 0xce,
	0x2e, 0x32, 0xf7, 0xe8, 0x34, 0xcd, 0x20, 0x28, 0xcd, 0x66, 0x91, 0x12, 0x1a, 0x58, 0x7e, 0x67,
	0x7f, 0xd0, 0x23, 0x80, 0x6a, 0x20, 0x2e, 0x03, 0x96, 0x3f, 0x0d, 0x18, 0x0d, 0xc3, 0x2b, 0x97,
	0x81, 0x14, 0x61, 0xfe, 0x65, 0x01, 0x96, 0x73, 0x1e, 0x33, 0xd0, 0x57, 0xb0, 0xc6, 0xae, 0xeb,
	0x96, 0x64, 0xfb, 0xcb, 0x45, 0xfc, 0x83, 0x74, 0x88, 0x82, 0x2e, 0xcc, 0xb3, 0xef, 0x87, 0x7c,
	0x9b, 0x9e, 0x92, 0x33, 0x47, 0x26, 0x20, 0x91, 0x53, 0x9e, 0xdf, 0xf6, 0x71, 0x45, 0x5a, 0x30,
	0x2b, 0x00, 0x5f, 0x11, 0x69, 0xfe, 0x11, 0xe8, 0x97, 0xa9, 0xd0, 0x2a, 0xdc, 0xc3, 0xbd, 0xfd,
	0xee, 0xf1, 0xe1, 0xce, 0xcb, 0x71, 0x77, 0x6f, 0xd4, 0xc3, 0xe3, 0x51, 0xff, 0xa0, 0x37, 0x38,
	0x1e, 0xe9, 0x77, 0x90, 0x0e, 0x8d, 0x6f, 0xba, 0xfd, 0xd1, 0x78, 0x6f, 0x80, 0x7b, 0xaf, 0x7b,
	0x58, 0xd7, 0xcc, 0x36, 0x54, 0xd4, 0x83, 0xc7, 0x95, 0x23, 0x7d, 0x0f, 0x2a, 0xaa, 0x3e, 0x89,
	0x02, 0x43, 0x34, 0x32, 0x7f, 0xa7, 0xc1, 0xe2, 0xa5, 0x37, 0x0e, 0xf4, 0x07, 0x73, 0x5d, 0x85,
	0x9f, 0xdd, 0xe6, 0x5d, 0x24, 0x5b, 0xe5, 0xe4, 0x55, 0x17, 0xdb, 0xb0, 0xa0, 0x5e, 0x60, 0x30,
	0x3d, 0x89, 0x2e, 0xfa, 0x37, 0xbd, 0xb7, 0x0c, 0x63, 0x5a, 0x9c, 0xb2, 0x99, 0x1f, 0x47, 0x8d,
	0xac, 0xb9, 0x37, 0x7e, 0x80, 0xca, 0xb0, 0xb7, 0x83, 0x7b, 0x23, 0x5d, 0x33, 0x1f, 0xc7, 0x5b,
	0x49, 0xd8, 0x45, 0x55, 0xa3, 0x04, 0xf4, 0x63, 0x65, 0x24, 0xe3, 0x47, 0x4f, 0xa0, 0x39, 0xf7,
	0x00, 0x82, 0x96, 0x60, 0xfe, 0x09, 0x44, 0xd7, 0xd0, 0x22, 0xd4, 0x07, 0xae, 0x9d, 0x00, 0x0a,
	0xdb, 0x1f, 0x41, 0xde, 0x2f, 0xe2, 0xb6, 0x2b, 0xf2, 0x37, 0x23, 0xe1, 0xff, 0x04, 0x00, 0x00,
	0xff, 0xff, 0xd6, 0xd8, 0x59, 0x15, 0x3f, 0x27, 0x00, 0x00,
}
